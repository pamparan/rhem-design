import {
  require_react_dom
} from "./chunk-QXLG2TGQ.js";
import {
  __rest,
  angle_left_icon_default,
  angle_right_icon_default,
  bell_icon_default,
  caret_down_icon_default,
  check_circle_icon_default,
  check_icon_default,
  cog_icon_default,
  exclamation_circle_icon_default,
  exclamation_triangle_icon_default,
  external_link_alt_icon_default,
  info_circle_icon_default,
  outlined_star_icon_default,
  star_icon_default,
  times_icon_default
} from "./chunk-6HWQWHJU.js";
import {
  require_jsx_runtime
} from "./chunk-GRWX7YRK.js";
import {
  __toESM,
  require_react
} from "./chunk-I4MZPW7S.js";

// node_modules/@patternfly/react-tokens/dist/esm/t_global_breakpoint_sm.js
var t_global_breakpoint_sm = {
  "name": "--pf-t--global--breakpoint--sm",
  "value": "36rem",
  "var": "var(--pf-t--global--breakpoint--sm)"
};
var t_global_breakpoint_sm_default = t_global_breakpoint_sm;

// node_modules/@patternfly/react-tokens/dist/esm/t_global_breakpoint_md.js
var t_global_breakpoint_md = {
  "name": "--pf-t--global--breakpoint--md",
  "value": "48rem",
  "var": "var(--pf-t--global--breakpoint--md)"
};
var t_global_breakpoint_md_default = t_global_breakpoint_md;

// node_modules/@patternfly/react-tokens/dist/esm/t_global_breakpoint_lg.js
var t_global_breakpoint_lg = {
  "name": "--pf-t--global--breakpoint--lg",
  "value": "62rem",
  "var": "var(--pf-t--global--breakpoint--lg)"
};
var t_global_breakpoint_lg_default = t_global_breakpoint_lg;

// node_modules/@patternfly/react-tokens/dist/esm/t_global_breakpoint_xl.js
var t_global_breakpoint_xl = {
  "name": "--pf-t--global--breakpoint--xl",
  "value": "75rem",
  "var": "var(--pf-t--global--breakpoint--xl)"
};
var t_global_breakpoint_xl_default = t_global_breakpoint_xl;

// node_modules/@patternfly/react-tokens/dist/esm/t_global_breakpoint_2xl.js
var t_global_breakpoint_2xl = {
  "name": "--pf-t--global--breakpoint--2xl",
  "value": "90.625rem",
  "var": "var(--pf-t--global--breakpoint--2xl)"
};
var t_global_breakpoint_2xl_default = t_global_breakpoint_2xl;

// node_modules/@patternfly/react-tokens/dist/esm/t_global_breakpoint_height_sm.js
var t_global_breakpoint_height_sm = {
  "name": "--pf-t--global--breakpoint--height--sm",
  "value": "0rem",
  "var": "var(--pf-t--global--breakpoint--height--sm)"
};
var t_global_breakpoint_height_sm_default = t_global_breakpoint_height_sm;

// node_modules/@patternfly/react-tokens/dist/esm/t_global_breakpoint_height_md.js
var t_global_breakpoint_height_md = {
  "name": "--pf-t--global--breakpoint--height--md",
  "value": "40rem",
  "var": "var(--pf-t--global--breakpoint--height--md)"
};
var t_global_breakpoint_height_md_default = t_global_breakpoint_height_md;

// node_modules/@patternfly/react-tokens/dist/esm/t_global_breakpoint_height_lg.js
var t_global_breakpoint_height_lg = {
  "name": "--pf-t--global--breakpoint--height--lg",
  "value": "48rem",
  "var": "var(--pf-t--global--breakpoint--height--lg)"
};
var t_global_breakpoint_height_lg_default = t_global_breakpoint_height_lg;

// node_modules/@patternfly/react-tokens/dist/esm/t_global_breakpoint_height_xl.js
var t_global_breakpoint_height_xl = {
  "name": "--pf-t--global--breakpoint--height--xl",
  "value": "60rem",
  "var": "var(--pf-t--global--breakpoint--height--xl)"
};
var t_global_breakpoint_height_xl_default = t_global_breakpoint_height_xl;

// node_modules/@patternfly/react-tokens/dist/esm/t_global_breakpoint_height_2xl.js
var t_global_breakpoint_height_2xl = {
  "name": "--pf-t--global--breakpoint--height--2xl",
  "value": "80rem",
  "var": "var(--pf-t--global--breakpoint--height--2xl)"
};
var t_global_breakpoint_height_2xl_default = t_global_breakpoint_height_2xl;

// node_modules/@patternfly/react-core/dist/esm/helpers/constants.js
var SIDE = { RIGHT: "right", LEFT: "left", BOTH: "both", NONE: "none" };
var KEYHANDLER_DIRECTION = { UP: "up", DOWN: "down", RIGHT: "right", LEFT: "left" };
var ValidatedOptions;
(function(ValidatedOptions2) {
  ValidatedOptions2["success"] = "success";
  ValidatedOptions2["error"] = "error";
  ValidatedOptions2["warning"] = "warning";
  ValidatedOptions2["default"] = "default";
})(ValidatedOptions || (ValidatedOptions = {}));
var KeyTypes = {
  Tab: "Tab",
  Space: " ",
  Escape: "Escape",
  Enter: "Enter",
  ArrowUp: "ArrowUp",
  ArrowDown: "ArrowDown",
  ArrowLeft: "ArrowLeft",
  ArrowRight: "ArrowRight"
};
var globalWidthBreakpoints = {
  sm: parseInt(t_global_breakpoint_sm_default.value) * 16,
  md: parseInt(t_global_breakpoint_md_default.value) * 16,
  lg: parseInt(t_global_breakpoint_lg_default.value) * 16,
  xl: parseInt(t_global_breakpoint_xl_default.value) * 16,
  "2xl": parseInt(t_global_breakpoint_2xl_default.value) * 16
};
var globalHeightBreakpoints = {
  sm: parseInt(t_global_breakpoint_height_sm_default.value) * 16,
  md: parseInt(t_global_breakpoint_height_md_default.value) * 16,
  lg: parseInt(t_global_breakpoint_height_lg_default.value) * 16,
  xl: parseInt(t_global_breakpoint_height_xl_default.value) * 16,
  "2xl": parseInt(t_global_breakpoint_height_2xl_default.value) * 16
};
var statusIcons = {
  success: check_circle_icon_default,
  danger: exclamation_circle_icon_default,
  warning: exclamation_triangle_icon_default,
  info: info_circle_icon_default,
  custom: bell_icon_default
};

// node_modules/@patternfly/react-core/dist/esm/helpers/FocusTrap/FocusTrap.js
var import_jsx_runtime = __toESM(require_jsx_runtime());

// node_modules/tabbable/dist/index.esm.js
var candidateSelectors = ["input:not([inert])", "select:not([inert])", "textarea:not([inert])", "a[href]:not([inert])", "button:not([inert])", "[tabindex]:not(slot):not([inert])", "audio[controls]:not([inert])", "video[controls]:not([inert])", '[contenteditable]:not([contenteditable="false"]):not([inert])', "details>summary:first-of-type:not([inert])", "details:not([inert])"];
var candidateSelector = candidateSelectors.join(",");
var NoElement = typeof Element === "undefined";
var matches = NoElement ? function() {
} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
var getRootNode = !NoElement && Element.prototype.getRootNode ? function(element) {
  var _element$getRootNode;
  return element === null || element === void 0 ? void 0 : (_element$getRootNode = element.getRootNode) === null || _element$getRootNode === void 0 ? void 0 : _element$getRootNode.call(element);
} : function(element) {
  return element === null || element === void 0 ? void 0 : element.ownerDocument;
};
var isInert = function isInert2(node, lookUp) {
  var _node$getAttribute;
  if (lookUp === void 0) {
    lookUp = true;
  }
  var inertAtt = node === null || node === void 0 ? void 0 : (_node$getAttribute = node.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node, "inert");
  var inert = inertAtt === "" || inertAtt === "true";
  var result = inert || lookUp && node && isInert2(node.parentNode);
  return result;
};
var isContentEditable = function isContentEditable2(node) {
  var _node$getAttribute2;
  var attValue = node === null || node === void 0 ? void 0 : (_node$getAttribute2 = node.getAttribute) === null || _node$getAttribute2 === void 0 ? void 0 : _node$getAttribute2.call(node, "contenteditable");
  return attValue === "" || attValue === "true";
};
var getCandidates = function getCandidates2(el, includeContainer, filter) {
  if (isInert(el)) {
    return [];
  }
  var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));
  if (includeContainer && matches.call(el, candidateSelector)) {
    candidates.unshift(el);
  }
  candidates = candidates.filter(filter);
  return candidates;
};
var getCandidatesIteratively = function getCandidatesIteratively2(elements, includeContainer, options) {
  var candidates = [];
  var elementsToCheck = Array.from(elements);
  while (elementsToCheck.length) {
    var element = elementsToCheck.shift();
    if (isInert(element, false)) {
      continue;
    }
    if (element.tagName === "SLOT") {
      var assigned = element.assignedElements();
      var content = assigned.length ? assigned : element.children;
      var nestedCandidates = getCandidatesIteratively2(content, true, options);
      if (options.flatten) {
        candidates.push.apply(candidates, nestedCandidates);
      } else {
        candidates.push({
          scopeParent: element,
          candidates: nestedCandidates
        });
      }
    } else {
      var validCandidate = matches.call(element, candidateSelector);
      if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {
        candidates.push(element);
      }
      var shadowRoot = element.shadowRoot || // check for an undisclosed shadow
      typeof options.getShadowRoot === "function" && options.getShadowRoot(element);
      var validShadowRoot = !isInert(shadowRoot, false) && (!options.shadowRootFilter || options.shadowRootFilter(element));
      if (shadowRoot && validShadowRoot) {
        var _nestedCandidates = getCandidatesIteratively2(shadowRoot === true ? element.children : shadowRoot.children, true, options);
        if (options.flatten) {
          candidates.push.apply(candidates, _nestedCandidates);
        } else {
          candidates.push({
            scopeParent: element,
            candidates: _nestedCandidates
          });
        }
      } else {
        elementsToCheck.unshift.apply(elementsToCheck, element.children);
      }
    }
  }
  return candidates;
};
var hasTabIndex = function hasTabIndex2(node) {
  return !isNaN(parseInt(node.getAttribute("tabindex"), 10));
};
var getTabIndex = function getTabIndex2(node) {
  if (!node) {
    throw new Error("No node provided");
  }
  if (node.tabIndex < 0) {
    if ((/^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || isContentEditable(node)) && !hasTabIndex(node)) {
      return 0;
    }
  }
  return node.tabIndex;
};
var getSortOrderTabIndex = function getSortOrderTabIndex2(node, isScope) {
  var tabIndex = getTabIndex(node);
  if (tabIndex < 0 && isScope && !hasTabIndex(node)) {
    return 0;
  }
  return tabIndex;
};
var sortOrderedTabbables = function sortOrderedTabbables2(a, b) {
  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;
};
var isInput = function isInput2(node) {
  return node.tagName === "INPUT";
};
var isHiddenInput = function isHiddenInput2(node) {
  return isInput(node) && node.type === "hidden";
};
var isDetailsWithSummary = function isDetailsWithSummary2(node) {
  var r = node.tagName === "DETAILS" && Array.prototype.slice.apply(node.children).some(function(child) {
    return child.tagName === "SUMMARY";
  });
  return r;
};
var getCheckedRadio = function getCheckedRadio2(nodes, form) {
  for (var i = 0; i < nodes.length; i++) {
    if (nodes[i].checked && nodes[i].form === form) {
      return nodes[i];
    }
  }
};
var isTabbableRadio = function isTabbableRadio2(node) {
  if (!node.name) {
    return true;
  }
  var radioScope = node.form || getRootNode(node);
  var queryRadios = function queryRadios2(name) {
    return radioScope.querySelectorAll('input[type="radio"][name="' + name + '"]');
  };
  var radioSet;
  if (typeof window !== "undefined" && typeof window.CSS !== "undefined" && typeof window.CSS.escape === "function") {
    radioSet = queryRadios(window.CSS.escape(node.name));
  } else {
    try {
      radioSet = queryRadios(node.name);
    } catch (err) {
      console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", err.message);
      return false;
    }
  }
  var checked = getCheckedRadio(radioSet, node.form);
  return !checked || checked === node;
};
var isRadio = function isRadio2(node) {
  return isInput(node) && node.type === "radio";
};
var isNonTabbableRadio = function isNonTabbableRadio2(node) {
  return isRadio(node) && !isTabbableRadio(node);
};
var isNodeAttached = function isNodeAttached2(node) {
  var _nodeRoot;
  var nodeRoot = node && getRootNode(node);
  var nodeRootHost = (_nodeRoot = nodeRoot) === null || _nodeRoot === void 0 ? void 0 : _nodeRoot.host;
  var attached = false;
  if (nodeRoot && nodeRoot !== node) {
    var _nodeRootHost, _nodeRootHost$ownerDo, _node$ownerDocument;
    attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && (_nodeRootHost$ownerDo = _nodeRootHost.ownerDocument) !== null && _nodeRootHost$ownerDo !== void 0 && _nodeRootHost$ownerDo.contains(nodeRootHost) || node !== null && node !== void 0 && (_node$ownerDocument = node.ownerDocument) !== null && _node$ownerDocument !== void 0 && _node$ownerDocument.contains(node));
    while (!attached && nodeRootHost) {
      var _nodeRoot2, _nodeRootHost2, _nodeRootHost2$ownerD;
      nodeRoot = getRootNode(nodeRootHost);
      nodeRootHost = (_nodeRoot2 = nodeRoot) === null || _nodeRoot2 === void 0 ? void 0 : _nodeRoot2.host;
      attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && (_nodeRootHost2$ownerD = _nodeRootHost2.ownerDocument) !== null && _nodeRootHost2$ownerD !== void 0 && _nodeRootHost2$ownerD.contains(nodeRootHost));
    }
  }
  return attached;
};
var isZeroArea = function isZeroArea2(node) {
  var _node$getBoundingClie = node.getBoundingClientRect(), width = _node$getBoundingClie.width, height = _node$getBoundingClie.height;
  return width === 0 && height === 0;
};
var isHidden = function isHidden2(node, _ref) {
  var displayCheck = _ref.displayCheck, getShadowRoot = _ref.getShadowRoot;
  if (getComputedStyle(node).visibility === "hidden") {
    return true;
  }
  var isDirectSummary = matches.call(node, "details>summary:first-of-type");
  var nodeUnderDetails = isDirectSummary ? node.parentElement : node;
  if (matches.call(nodeUnderDetails, "details:not([open]) *")) {
    return true;
  }
  if (!displayCheck || displayCheck === "full" || displayCheck === "legacy-full") {
    if (typeof getShadowRoot === "function") {
      var originalNode = node;
      while (node) {
        var parentElement = node.parentElement;
        var rootNode = getRootNode(node);
        if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true) {
          return isZeroArea(node);
        } else if (node.assignedSlot) {
          node = node.assignedSlot;
        } else if (!parentElement && rootNode !== node.ownerDocument) {
          node = rootNode.host;
        } else {
          node = parentElement;
        }
      }
      node = originalNode;
    }
    if (isNodeAttached(node)) {
      return !node.getClientRects().length;
    }
    if (displayCheck !== "legacy-full") {
      return true;
    }
  } else if (displayCheck === "non-zero-area") {
    return isZeroArea(node);
  }
  return false;
};
var isDisabledFromFieldset = function isDisabledFromFieldset2(node) {
  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {
    var parentNode = node.parentElement;
    while (parentNode) {
      if (parentNode.tagName === "FIELDSET" && parentNode.disabled) {
        for (var i = 0; i < parentNode.children.length; i++) {
          var child = parentNode.children.item(i);
          if (child.tagName === "LEGEND") {
            return matches.call(parentNode, "fieldset[disabled] *") ? true : !child.contains(node);
          }
        }
        return true;
      }
      parentNode = parentNode.parentElement;
    }
  }
  return false;
};
var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable2(options, node) {
  if (node.disabled || // we must do an inert look up to filter out any elements inside an inert ancestor
  //  because we're limited in the type of selectors we can use in JSDom (see related
  //  note related to `candidateSelectors`)
  isInert(node) || isHiddenInput(node) || isHidden(node, options) || // For a details element with a summary, the summary element gets the focus
  isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
    return false;
  }
  return true;
};
var isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable2(options, node) {
  if (isNonTabbableRadio(node) || getTabIndex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {
    return false;
  }
  return true;
};
var isValidShadowRootTabbable = function isValidShadowRootTabbable2(shadowHostNode) {
  var tabIndex = parseInt(shadowHostNode.getAttribute("tabindex"), 10);
  if (isNaN(tabIndex) || tabIndex >= 0) {
    return true;
  }
  return false;
};
var sortByOrder = function sortByOrder2(candidates) {
  var regularTabbables = [];
  var orderedTabbables = [];
  candidates.forEach(function(item, i) {
    var isScope = !!item.scopeParent;
    var element = isScope ? item.scopeParent : item;
    var candidateTabindex = getSortOrderTabIndex(element, isScope);
    var elements = isScope ? sortByOrder2(item.candidates) : element;
    if (candidateTabindex === 0) {
      isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);
    } else {
      orderedTabbables.push({
        documentOrder: i,
        tabIndex: candidateTabindex,
        item,
        isScope,
        content: elements
      });
    }
  });
  return orderedTabbables.sort(sortOrderedTabbables).reduce(function(acc, sortable) {
    sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);
    return acc;
  }, []).concat(regularTabbables);
};
var tabbable = function tabbable2(container, options) {
  options = options || {};
  var candidates;
  if (options.getShadowRoot) {
    candidates = getCandidatesIteratively([container], options.includeContainer, {
      filter: isNodeMatchingSelectorTabbable.bind(null, options),
      flatten: false,
      getShadowRoot: options.getShadowRoot,
      shadowRootFilter: isValidShadowRootTabbable
    });
  } else {
    candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));
  }
  return sortByOrder(candidates);
};
var focusable = function focusable2(container, options) {
  options = options || {};
  var candidates;
  if (options.getShadowRoot) {
    candidates = getCandidatesIteratively([container], options.includeContainer, {
      filter: isNodeMatchingSelectorFocusable.bind(null, options),
      flatten: true,
      getShadowRoot: options.getShadowRoot
    });
  } else {
    candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));
  }
  return candidates;
};
var isTabbable = function isTabbable2(node, options) {
  options = options || {};
  if (!node) {
    throw new Error("No node provided");
  }
  if (matches.call(node, candidateSelector) === false) {
    return false;
  }
  return isNodeMatchingSelectorTabbable(options, node);
};
var focusableCandidateSelector = candidateSelectors.concat("iframe").join(",");
var isFocusable = function isFocusable2(node, options) {
  options = options || {};
  if (!node) {
    throw new Error("No node provided");
  }
  if (matches.call(node, focusableCandidateSelector) === false) {
    return false;
  }
  return isNodeMatchingSelectorFocusable(options, node);
};

// node_modules/focus-trap/dist/focus-trap.esm.js
function _arrayLikeToArray(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
function _arrayWithoutHoles(r) {
  if (Array.isArray(r)) return _arrayLikeToArray(r);
}
function _defineProperty(e, r, t) {
  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e[r] = t, e;
}
function _iterableToArray(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _toConsumableArray(r) {
  return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();
}
function _toPrimitive(t, r) {
  if ("object" != typeof t || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _unsupportedIterableToArray(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
  }
}
var activeFocusTraps = {
  activateTrap: function activateTrap(trapStack, trap) {
    if (trapStack.length > 0) {
      var activeTrap = trapStack[trapStack.length - 1];
      if (activeTrap !== trap) {
        activeTrap._setPausedState(true);
      }
    }
    var trapIndex = trapStack.indexOf(trap);
    if (trapIndex === -1) {
      trapStack.push(trap);
    } else {
      trapStack.splice(trapIndex, 1);
      trapStack.push(trap);
    }
  },
  deactivateTrap: function deactivateTrap(trapStack, trap) {
    var trapIndex = trapStack.indexOf(trap);
    if (trapIndex !== -1) {
      trapStack.splice(trapIndex, 1);
    }
    if (trapStack.length > 0 && !trapStack[trapStack.length - 1]._isManuallyPaused()) {
      trapStack[trapStack.length - 1]._setPausedState(false);
    }
  }
};
var isSelectableInput = function isSelectableInput2(node) {
  return node.tagName && node.tagName.toLowerCase() === "input" && typeof node.select === "function";
};
var isEscapeEvent = function isEscapeEvent2(e) {
  return (e === null || e === void 0 ? void 0 : e.key) === "Escape" || (e === null || e === void 0 ? void 0 : e.key) === "Esc" || (e === null || e === void 0 ? void 0 : e.keyCode) === 27;
};
var isTabEvent = function isTabEvent2(e) {
  return (e === null || e === void 0 ? void 0 : e.key) === "Tab" || (e === null || e === void 0 ? void 0 : e.keyCode) === 9;
};
var isKeyForward = function isKeyForward2(e) {
  return isTabEvent(e) && !e.shiftKey;
};
var isKeyBackward = function isKeyBackward2(e) {
  return isTabEvent(e) && e.shiftKey;
};
var delay = function delay2(fn) {
  return setTimeout(fn, 0);
};
var valueOrHandler = function valueOrHandler2(value) {
  for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    params[_key - 1] = arguments[_key];
  }
  return typeof value === "function" ? value.apply(void 0, params) : value;
};
var getActualTarget = function getActualTarget2(event) {
  return event.target.shadowRoot && typeof event.composedPath === "function" ? event.composedPath()[0] : event.target;
};
var internalTrapStack = [];
var createFocusTrap = function createFocusTrap2(elements, userOptions) {
  var doc = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.document) || document;
  var trapStack = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.trapStack) || internalTrapStack;
  var config = _objectSpread2({
    returnFocusOnDeactivate: true,
    escapeDeactivates: true,
    delayInitialFocus: true,
    isKeyForward,
    isKeyBackward
  }, userOptions);
  var state = {
    // containers given to createFocusTrap()
    // @type {Array<HTMLElement>}
    containers: [],
    // list of objects identifying tabbable nodes in `containers` in the trap
    // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap
    //  is active, but the trap should never get to a state where there isn't at least one group
    //  with at least one tabbable node in it (that would lead to an error condition that would
    //  result in an error being thrown)
    // @type {Array<{
    //   container: HTMLElement,
    //   tabbableNodes: Array<HTMLElement>, // empty if none
    //   focusableNodes: Array<HTMLElement>, // empty if none
    //   posTabIndexesFound: boolean,
    //   firstTabbableNode: HTMLElement|undefined,
    //   lastTabbableNode: HTMLElement|undefined,
    //   firstDomTabbableNode: HTMLElement|undefined,
    //   lastDomTabbableNode: HTMLElement|undefined,
    //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined
    // }>}
    containerGroups: [],
    // same order/length as `containers` list
    // references to objects in `containerGroups`, but only those that actually have
    //  tabbable nodes in them
    // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__
    //  the same length
    tabbableGroups: [],
    nodeFocusedBeforeActivation: null,
    mostRecentlyFocusedNode: null,
    active: false,
    paused: false,
    manuallyPaused: false,
    // timer ID for when delayInitialFocus is true and initial focus in this trap
    //  has been delayed during activation
    delayInitialFocusTimer: void 0,
    // the most recent KeyboardEvent for the configured nav key (typically [SHIFT+]TAB), if any
    recentNavEvent: void 0
  };
  var trap;
  var getOption = function getOption2(configOverrideOptions, optionName, configOptionName) {
    return configOverrideOptions && configOverrideOptions[optionName] !== void 0 ? configOverrideOptions[optionName] : config[configOptionName || optionName];
  };
  var findContainerIndex = function findContainerIndex2(element, event) {
    var composedPath = typeof (event === null || event === void 0 ? void 0 : event.composedPath) === "function" ? event.composedPath() : void 0;
    return state.containerGroups.findIndex(function(_ref) {
      var container = _ref.container, tabbableNodes = _ref.tabbableNodes;
      return container.contains(element) || // fall back to explicit tabbable search which will take into consideration any
      //  web components if the `tabbableOptions.getShadowRoot` option was used for
      //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't
      //  look inside web components even if open)
      (composedPath === null || composedPath === void 0 ? void 0 : composedPath.includes(container)) || tabbableNodes.find(function(node) {
        return node === element;
      });
    });
  };
  var getNodeForOption = function getNodeForOption2(optionName) {
    var _ref2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref2$hasFallback = _ref2.hasFallback, hasFallback = _ref2$hasFallback === void 0 ? false : _ref2$hasFallback, _ref2$params = _ref2.params, params = _ref2$params === void 0 ? [] : _ref2$params;
    var optionValue = config[optionName];
    if (typeof optionValue === "function") {
      optionValue = optionValue.apply(void 0, _toConsumableArray(params));
    }
    if (optionValue === true) {
      optionValue = void 0;
    }
    if (!optionValue) {
      if (optionValue === void 0 || optionValue === false) {
        return optionValue;
      }
      throw new Error("`".concat(optionName, "` was specified but was not a node, or did not return a node"));
    }
    var node = optionValue;
    if (typeof optionValue === "string") {
      try {
        node = doc.querySelector(optionValue);
      } catch (err) {
        throw new Error("`".concat(optionName, '` appears to be an invalid selector; error="').concat(err.message, '"'));
      }
      if (!node) {
        if (!hasFallback) {
          throw new Error("`".concat(optionName, "` as selector refers to no known node"));
        }
      }
    }
    return node;
  };
  var getInitialFocusNode = function getInitialFocusNode2() {
    var node = getNodeForOption("initialFocus", {
      hasFallback: true
    });
    if (node === false) {
      return false;
    }
    if (node === void 0 || node && !isFocusable(node, config.tabbableOptions)) {
      if (findContainerIndex(doc.activeElement) >= 0) {
        node = doc.activeElement;
      } else {
        var firstTabbableGroup = state.tabbableGroups[0];
        var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;
        node = firstTabbableNode || getNodeForOption("fallbackFocus");
      }
    } else if (node === null) {
      node = getNodeForOption("fallbackFocus");
    }
    if (!node) {
      throw new Error("Your focus-trap needs to have at least one focusable element");
    }
    return node;
  };
  var updateTabbableNodes = function updateTabbableNodes2() {
    state.containerGroups = state.containers.map(function(container) {
      var tabbableNodes = tabbable(container, config.tabbableOptions);
      var focusableNodes = focusable(container, config.tabbableOptions);
      var firstTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[0] : void 0;
      var lastTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : void 0;
      var firstDomTabbableNode = focusableNodes.find(function(node) {
        return isTabbable(node);
      });
      var lastDomTabbableNode = focusableNodes.slice().reverse().find(function(node) {
        return isTabbable(node);
      });
      var posTabIndexesFound = !!tabbableNodes.find(function(node) {
        return getTabIndex(node) > 0;
      });
      return {
        container,
        tabbableNodes,
        focusableNodes,
        /** True if at least one node with positive `tabindex` was found in this container. */
        posTabIndexesFound,
        /** First tabbable node in container, __tabindex__ order; `undefined` if none. */
        firstTabbableNode,
        /** Last tabbable node in container, __tabindex__ order; `undefined` if none. */
        lastTabbableNode,
        // NOTE: DOM order is NOT NECESSARILY "document position" order, but figuring that out
        //  would require more than just https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition
        //  because that API doesn't work with Shadow DOM as well as it should (@see
        //  https://github.com/whatwg/dom/issues/320) and since this first/last is only needed, so far,
        //  to address an edge case related to positive tabindex support, this seems like a much easier,
        //  "close enough most of the time" alternative for positive tabindexes which should generally
        //  be avoided anyway...
        /** First tabbable node in container, __DOM__ order; `undefined` if none. */
        firstDomTabbableNode,
        /** Last tabbable node in container, __DOM__ order; `undefined` if none. */
        lastDomTabbableNode,
        /**
         * Finds the __tabbable__ node that follows the given node in the specified direction,
         *  in this container, if any.
         * @param {HTMLElement} node
         * @param {boolean} [forward] True if going in forward tab order; false if going
         *  in reverse.
         * @returns {HTMLElement|undefined} The next tabbable node, if any.
         */
        nextTabbableNode: function nextTabbableNode(node) {
          var forward = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
          var nodeIdx = tabbableNodes.indexOf(node);
          if (nodeIdx < 0) {
            if (forward) {
              return focusableNodes.slice(focusableNodes.indexOf(node) + 1).find(function(el) {
                return isTabbable(el);
              });
            }
            return focusableNodes.slice(0, focusableNodes.indexOf(node)).reverse().find(function(el) {
              return isTabbable(el);
            });
          }
          return tabbableNodes[nodeIdx + (forward ? 1 : -1)];
        }
      };
    });
    state.tabbableGroups = state.containerGroups.filter(function(group) {
      return group.tabbableNodes.length > 0;
    });
    if (state.tabbableGroups.length <= 0 && !getNodeForOption("fallbackFocus")) {
      throw new Error("Your focus-trap must have at least one container with at least one tabbable node in it at all times");
    }
    if (state.containerGroups.find(function(g) {
      return g.posTabIndexesFound;
    }) && state.containerGroups.length > 1) {
      throw new Error("At least one node with a positive tabindex was found in one of your focus-trap's multiple containers. Positive tabindexes are only supported in single-container focus-traps.");
    }
  };
  var _getActiveElement = function getActiveElement(el) {
    var activeElement = el.activeElement;
    if (!activeElement) {
      return;
    }
    if (activeElement.shadowRoot && activeElement.shadowRoot.activeElement !== null) {
      return _getActiveElement(activeElement.shadowRoot);
    }
    return activeElement;
  };
  var _tryFocus = function tryFocus(node) {
    if (node === false) {
      return;
    }
    if (node === _getActiveElement(document)) {
      return;
    }
    if (!node || !node.focus) {
      _tryFocus(getInitialFocusNode());
      return;
    }
    node.focus({
      preventScroll: !!config.preventScroll
    });
    state.mostRecentlyFocusedNode = node;
    if (isSelectableInput(node)) {
      node.select();
    }
  };
  var getReturnFocusNode = function getReturnFocusNode2(previousActiveElement) {
    var node = getNodeForOption("setReturnFocus", {
      params: [previousActiveElement]
    });
    return node ? node : node === false ? false : previousActiveElement;
  };
  var findNextNavNode = function findNextNavNode2(_ref3) {
    var target = _ref3.target, event = _ref3.event, _ref3$isBackward = _ref3.isBackward, isBackward = _ref3$isBackward === void 0 ? false : _ref3$isBackward;
    target = target || getActualTarget(event);
    updateTabbableNodes();
    var destinationNode = null;
    if (state.tabbableGroups.length > 0) {
      var containerIndex = findContainerIndex(target, event);
      var containerGroup = containerIndex >= 0 ? state.containerGroups[containerIndex] : void 0;
      if (containerIndex < 0) {
        if (isBackward) {
          destinationNode = state.tabbableGroups[state.tabbableGroups.length - 1].lastTabbableNode;
        } else {
          destinationNode = state.tabbableGroups[0].firstTabbableNode;
        }
      } else if (isBackward) {
        var startOfGroupIndex = state.tabbableGroups.findIndex(function(_ref4) {
          var firstTabbableNode = _ref4.firstTabbableNode;
          return target === firstTabbableNode;
        });
        if (startOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target, false))) {
          startOfGroupIndex = containerIndex;
        }
        if (startOfGroupIndex >= 0) {
          var destinationGroupIndex = startOfGroupIndex === 0 ? state.tabbableGroups.length - 1 : startOfGroupIndex - 1;
          var destinationGroup = state.tabbableGroups[destinationGroupIndex];
          destinationNode = getTabIndex(target) >= 0 ? destinationGroup.lastTabbableNode : destinationGroup.lastDomTabbableNode;
        } else if (!isTabEvent(event)) {
          destinationNode = containerGroup.nextTabbableNode(target, false);
        }
      } else {
        var lastOfGroupIndex = state.tabbableGroups.findIndex(function(_ref5) {
          var lastTabbableNode = _ref5.lastTabbableNode;
          return target === lastTabbableNode;
        });
        if (lastOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target))) {
          lastOfGroupIndex = containerIndex;
        }
        if (lastOfGroupIndex >= 0) {
          var _destinationGroupIndex = lastOfGroupIndex === state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;
          var _destinationGroup = state.tabbableGroups[_destinationGroupIndex];
          destinationNode = getTabIndex(target) >= 0 ? _destinationGroup.firstTabbableNode : _destinationGroup.firstDomTabbableNode;
        } else if (!isTabEvent(event)) {
          destinationNode = containerGroup.nextTabbableNode(target);
        }
      }
    } else {
      destinationNode = getNodeForOption("fallbackFocus");
    }
    return destinationNode;
  };
  var checkPointerDown = function checkPointerDown2(e) {
    var target = getActualTarget(e);
    if (findContainerIndex(target, e) >= 0) {
      return;
    }
    if (valueOrHandler(config.clickOutsideDeactivates, e)) {
      trap.deactivate({
        // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,
        //  which will result in the outside click setting focus to the node
        //  that was clicked (and if not focusable, to "nothing"); by setting
        //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused
        //  on activation (or the configured `setReturnFocus` node), whether the
        //  outside click was on a focusable node or not
        returnFocus: config.returnFocusOnDeactivate
      });
      return;
    }
    if (valueOrHandler(config.allowOutsideClick, e)) {
      return;
    }
    e.preventDefault();
  };
  var checkFocusIn = function checkFocusIn2(event) {
    var target = getActualTarget(event);
    var targetContained = findContainerIndex(target, event) >= 0;
    if (targetContained || target instanceof Document) {
      if (targetContained) {
        state.mostRecentlyFocusedNode = target;
      }
    } else {
      event.stopImmediatePropagation();
      var nextNode;
      var navAcrossContainers = true;
      if (state.mostRecentlyFocusedNode) {
        if (getTabIndex(state.mostRecentlyFocusedNode) > 0) {
          var mruContainerIdx = findContainerIndex(state.mostRecentlyFocusedNode);
          var tabbableNodes = state.containerGroups[mruContainerIdx].tabbableNodes;
          if (tabbableNodes.length > 0) {
            var mruTabIdx = tabbableNodes.findIndex(function(node) {
              return node === state.mostRecentlyFocusedNode;
            });
            if (mruTabIdx >= 0) {
              if (config.isKeyForward(state.recentNavEvent)) {
                if (mruTabIdx + 1 < tabbableNodes.length) {
                  nextNode = tabbableNodes[mruTabIdx + 1];
                  navAcrossContainers = false;
                }
              } else {
                if (mruTabIdx - 1 >= 0) {
                  nextNode = tabbableNodes[mruTabIdx - 1];
                  navAcrossContainers = false;
                }
              }
            }
          }
        } else {
          if (!state.containerGroups.some(function(g) {
            return g.tabbableNodes.some(function(n) {
              return getTabIndex(n) > 0;
            });
          })) {
            navAcrossContainers = false;
          }
        }
      } else {
        navAcrossContainers = false;
      }
      if (navAcrossContainers) {
        nextNode = findNextNavNode({
          // move FROM the MRU node, not event-related node (which will be the node that is
          //  outside the trap causing the focus escape we're trying to fix)
          target: state.mostRecentlyFocusedNode,
          isBackward: config.isKeyBackward(state.recentNavEvent)
        });
      }
      if (nextNode) {
        _tryFocus(nextNode);
      } else {
        _tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());
      }
    }
    state.recentNavEvent = void 0;
  };
  var checkKeyNav = function checkKeyNav2(event) {
    var isBackward = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    state.recentNavEvent = event;
    var destinationNode = findNextNavNode({
      event,
      isBackward
    });
    if (destinationNode) {
      if (isTabEvent(event)) {
        event.preventDefault();
      }
      _tryFocus(destinationNode);
    }
  };
  var checkTabKey = function checkTabKey2(event) {
    if (config.isKeyForward(event) || config.isKeyBackward(event)) {
      checkKeyNav(event, config.isKeyBackward(event));
    }
  };
  var checkEscapeKey = function checkEscapeKey2(event) {
    if (isEscapeEvent(event) && valueOrHandler(config.escapeDeactivates, event) !== false) {
      event.preventDefault();
      trap.deactivate();
    }
  };
  var checkClick = function checkClick2(e) {
    var target = getActualTarget(e);
    if (findContainerIndex(target, e) >= 0) {
      return;
    }
    if (valueOrHandler(config.clickOutsideDeactivates, e)) {
      return;
    }
    if (valueOrHandler(config.allowOutsideClick, e)) {
      return;
    }
    e.preventDefault();
    e.stopImmediatePropagation();
  };
  var addListeners = function addListeners2() {
    if (!state.active) {
      return;
    }
    activeFocusTraps.activateTrap(trapStack, trap);
    state.delayInitialFocusTimer = config.delayInitialFocus ? delay(function() {
      _tryFocus(getInitialFocusNode());
    }) : _tryFocus(getInitialFocusNode());
    doc.addEventListener("focusin", checkFocusIn, true);
    doc.addEventListener("mousedown", checkPointerDown, {
      capture: true,
      passive: false
    });
    doc.addEventListener("touchstart", checkPointerDown, {
      capture: true,
      passive: false
    });
    doc.addEventListener("click", checkClick, {
      capture: true,
      passive: false
    });
    doc.addEventListener("keydown", checkTabKey, {
      capture: true,
      passive: false
    });
    doc.addEventListener("keydown", checkEscapeKey);
    return trap;
  };
  var removeListeners = function removeListeners2() {
    if (!state.active) {
      return;
    }
    doc.removeEventListener("focusin", checkFocusIn, true);
    doc.removeEventListener("mousedown", checkPointerDown, true);
    doc.removeEventListener("touchstart", checkPointerDown, true);
    doc.removeEventListener("click", checkClick, true);
    doc.removeEventListener("keydown", checkTabKey, true);
    doc.removeEventListener("keydown", checkEscapeKey);
    return trap;
  };
  var checkDomRemoval = function checkDomRemoval2(mutations) {
    var isFocusedNodeRemoved = mutations.some(function(mutation) {
      var removedNodes = Array.from(mutation.removedNodes);
      return removedNodes.some(function(node) {
        return node === state.mostRecentlyFocusedNode;
      });
    });
    if (isFocusedNodeRemoved) {
      _tryFocus(getInitialFocusNode());
    }
  };
  var mutationObserver = typeof window !== "undefined" && "MutationObserver" in window ? new MutationObserver(checkDomRemoval) : void 0;
  var updateObservedNodes = function updateObservedNodes2() {
    if (!mutationObserver) {
      return;
    }
    mutationObserver.disconnect();
    if (state.active && !state.paused) {
      state.containers.map(function(container) {
        mutationObserver.observe(container, {
          subtree: true,
          childList: true
        });
      });
    }
  };
  trap = {
    get active() {
      return state.active;
    },
    get paused() {
      return state.paused;
    },
    activate: function activate(activateOptions) {
      if (state.active) {
        return this;
      }
      var onActivate = getOption(activateOptions, "onActivate");
      var onPostActivate = getOption(activateOptions, "onPostActivate");
      var checkCanFocusTrap = getOption(activateOptions, "checkCanFocusTrap");
      if (!checkCanFocusTrap) {
        updateTabbableNodes();
      }
      state.active = true;
      state.paused = false;
      state.nodeFocusedBeforeActivation = doc.activeElement;
      onActivate === null || onActivate === void 0 || onActivate();
      var finishActivation = function finishActivation2() {
        if (checkCanFocusTrap) {
          updateTabbableNodes();
        }
        addListeners();
        updateObservedNodes();
        onPostActivate === null || onPostActivate === void 0 || onPostActivate();
      };
      if (checkCanFocusTrap) {
        checkCanFocusTrap(state.containers.concat()).then(finishActivation, finishActivation);
        return this;
      }
      finishActivation();
      return this;
    },
    deactivate: function deactivate(deactivateOptions) {
      if (!state.active) {
        return this;
      }
      var options = _objectSpread2({
        onDeactivate: config.onDeactivate,
        onPostDeactivate: config.onPostDeactivate,
        checkCanReturnFocus: config.checkCanReturnFocus
      }, deactivateOptions);
      clearTimeout(state.delayInitialFocusTimer);
      state.delayInitialFocusTimer = void 0;
      removeListeners();
      state.active = false;
      state.paused = false;
      updateObservedNodes();
      activeFocusTraps.deactivateTrap(trapStack, trap);
      var onDeactivate = getOption(options, "onDeactivate");
      var onPostDeactivate = getOption(options, "onPostDeactivate");
      var checkCanReturnFocus = getOption(options, "checkCanReturnFocus");
      var returnFocus = getOption(options, "returnFocus", "returnFocusOnDeactivate");
      onDeactivate === null || onDeactivate === void 0 || onDeactivate();
      var finishDeactivation = function finishDeactivation2() {
        delay(function() {
          if (returnFocus) {
            _tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));
          }
          onPostDeactivate === null || onPostDeactivate === void 0 || onPostDeactivate();
        });
      };
      if (returnFocus && checkCanReturnFocus) {
        checkCanReturnFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation)).then(finishDeactivation, finishDeactivation);
        return this;
      }
      finishDeactivation();
      return this;
    },
    pause: function pause(pauseOptions) {
      if (!state.active) {
        return this;
      }
      state.manuallyPaused = true;
      return this._setPausedState(true, pauseOptions);
    },
    unpause: function unpause(unpauseOptions) {
      if (!state.active) {
        return this;
      }
      state.manuallyPaused = false;
      if (trapStack[trapStack.length - 1] !== this) {
        return this;
      }
      return this._setPausedState(false, unpauseOptions);
    },
    updateContainerElements: function updateContainerElements(containerElements) {
      var elementsAsArray = [].concat(containerElements).filter(Boolean);
      state.containers = elementsAsArray.map(function(element) {
        return typeof element === "string" ? doc.querySelector(element) : element;
      });
      if (state.active) {
        updateTabbableNodes();
      }
      updateObservedNodes();
      return this;
    }
  };
  Object.defineProperties(trap, {
    _isManuallyPaused: {
      value: function value() {
        return state.manuallyPaused;
      }
    },
    _setPausedState: {
      value: function value(paused, options) {
        if (state.paused === paused) {
          return this;
        }
        state.paused = paused;
        if (paused) {
          var onPause = getOption(options, "onPause");
          var onPostPause = getOption(options, "onPostPause");
          onPause === null || onPause === void 0 || onPause();
          removeListeners();
          updateObservedNodes();
          onPostPause === null || onPostPause === void 0 || onPostPause();
        } else {
          var onUnpause = getOption(options, "onUnpause");
          var onPostUnpause = getOption(options, "onPostUnpause");
          onUnpause === null || onUnpause === void 0 || onUnpause();
          updateTabbableNodes();
          addListeners();
          updateObservedNodes();
          onPostUnpause === null || onPostUnpause === void 0 || onPostUnpause();
        }
        return this;
      }
    }
  });
  trap.updateContainerElements(elements);
  return trap;
};

// node_modules/@patternfly/react-core/dist/esm/helpers/FocusTrap/FocusTrap.js
var import_react2 = __toESM(require_react());

// node_modules/@patternfly/react-core/dist/esm/helpers/useUnmountEffect.js
var import_react = __toESM(require_react());
function useUnmountEffect(effect4) {
  const effectRef = (0, import_react.useRef)(effect4);
  effectRef.current = effect4;
  (0, import_react.useEffect)(() => () => {
    effectRef.current();
  }, []);
}

// node_modules/@patternfly/react-core/dist/esm/helpers/FocusTrap/FocusTrap.js
var FocusTrap = (0, import_react2.forwardRef)(function FocusTrap2(_a, forwardedRef) {
  var { active = true, paused = false, focusTrapOptions = {}, preventScrollOnDeactivate = false } = _a, props = __rest(_a, ["active", "paused", "focusTrapOptions", "preventScrollOnDeactivate"]);
  const ref = (0, import_react2.useRef)(null);
  (0, import_react2.useImperativeHandle)(forwardedRef, () => ref.current);
  const focusTrapRef = (0, import_react2.useRef)(null);
  (0, import_react2.useEffect)(() => {
    const focusTrap = createFocusTrap(ref.current, Object.assign(Object.assign({}, focusTrapOptions), { returnFocusOnDeactivate: false }));
    focusTrapRef.current = focusTrap;
    return () => {
      focusTrap.deactivate();
    };
  }, []);
  (0, import_react2.useEffect)(() => {
    const focusTrap = focusTrapRef.current;
    active ? focusTrap === null || focusTrap === void 0 ? void 0 : focusTrap.activate() : focusTrap === null || focusTrap === void 0 ? void 0 : focusTrap.deactivate();
  }, [active]);
  (0, import_react2.useEffect)(() => {
    const focusTrap = focusTrapRef.current;
    paused ? focusTrap === null || focusTrap === void 0 ? void 0 : focusTrap.pause() : focusTrap === null || focusTrap === void 0 ? void 0 : focusTrap.unpause();
  }, [paused]);
  const previousElementRef = (0, import_react2.useRef)(typeof document !== "undefined" ? document.activeElement : null);
  useUnmountEffect(() => {
    if (focusTrapOptions.returnFocusOnDeactivate !== false && previousElementRef.current instanceof HTMLElement) {
      previousElementRef.current.focus({
        preventScroll: preventScrollOnDeactivate
      });
    }
  });
  return (0, import_jsx_runtime.jsx)("div", Object.assign({ ref }, props));
});
FocusTrap.displayName = "FocusTrap";

// node_modules/@patternfly/react-core/dist/esm/helpers/util.js
function capitalize(input) {
  return input[0].toUpperCase() + input.substring(1);
}
function getUniqueId(prefix = "pf") {
  const uid2 = (/* @__PURE__ */ new Date()).getTime() + Math.random().toString(36).slice(2);
  return `${prefix}-${uid2}`;
}
function debounce(func, wait) {
  let timeout;
  return (...args) => {
    clearTimeout(timeout);
    timeout = setTimeout(() => func.apply(this, args), wait);
  };
}
function isElementInView(container, element, partial, strict = false) {
  if (!container || !element) {
    return false;
  }
  const containerBounds = container.getBoundingClientRect();
  const elementBounds = element.getBoundingClientRect();
  const containerBoundsLeft = Math.ceil(containerBounds.left);
  const containerBoundsRight = Math.floor(containerBounds.right);
  const elementBoundsLeft = Math.ceil(elementBounds.left);
  const elementBoundsRight = Math.floor(elementBounds.right);
  const isTotallyInView = elementBoundsLeft >= containerBoundsLeft && elementBoundsRight <= containerBoundsRight;
  const isPartiallyInView = (partial || !strict && containerBounds.width < elementBounds.width) && (elementBoundsLeft < containerBoundsLeft && elementBoundsRight > containerBoundsLeft || elementBoundsRight > containerBoundsRight && elementBoundsLeft < containerBoundsRight);
  return isTotallyInView || isPartiallyInView;
}
function sideElementIsOutOfView(container, element) {
  const containerBounds = container.getBoundingClientRect();
  const elementBounds = element.getBoundingClientRect();
  const containerBoundsLeft = Math.floor(containerBounds.left);
  const containerBoundsRight = Math.floor(containerBounds.right);
  const elementBoundsLeft = Math.floor(elementBounds.left);
  const elementBoundsRight = Math.floor(elementBounds.right);
  const isOffLeft = elementBoundsLeft < containerBoundsLeft;
  const isOffRight = elementBoundsRight > containerBoundsRight;
  let side = SIDE.NONE;
  if (isOffRight && isOffLeft) {
    side = SIDE.BOTH;
  } else if (isOffRight) {
    side = SIDE.RIGHT;
  } else if (isOffLeft) {
    side = SIDE.LEFT;
  }
  return side;
}
function fillTemplate(templateString, templateVars) {
  return templateString.replace(/\${(.*?)}/g, (_, match) => templateVars[match] || "");
}
function keyHandler(index, innerIndex, position, refsCollection, kids, custom = false) {
  if (!Array.isArray(kids)) {
    return;
  }
  const isMultiDimensional = refsCollection.filter((ref) => ref)[0].constructor === Array;
  let nextIndex = index;
  let nextInnerIndex = innerIndex;
  if (position === "up") {
    if (index === 0) {
      nextIndex = kids.length - 1;
    } else {
      nextIndex = index - 1;
    }
  } else if (position === "down") {
    if (index === kids.length - 1) {
      nextIndex = 0;
    } else {
      nextIndex = index + 1;
    }
  } else if (position === "left") {
    if (innerIndex === 0) {
      nextInnerIndex = refsCollection[index].length - 1;
    } else {
      nextInnerIndex = innerIndex - 1;
    }
  } else if (position === "right") {
    if (innerIndex === refsCollection[index].length - 1) {
      nextInnerIndex = 0;
    } else {
      nextInnerIndex = innerIndex + 1;
    }
  }
  if (refsCollection[nextIndex] === null || refsCollection[nextIndex] === void 0 || isMultiDimensional && (refsCollection[nextIndex][nextInnerIndex] === null || refsCollection[nextIndex][nextInnerIndex] === void 0)) {
    keyHandler(nextIndex, nextInnerIndex, position, refsCollection, kids, custom);
  } else if (custom) {
    if (refsCollection[nextIndex].focus) {
      refsCollection[nextIndex].focus();
    }
    const element = refsCollection[nextIndex];
    element.focus();
  } else if (position !== "tab") {
    if (isMultiDimensional) {
      refsCollection[nextIndex][nextInnerIndex].focus();
    } else {
      refsCollection[nextIndex].focus();
    }
  }
}
function findTabbableElements(containerRef, tababbleSelectors) {
  const tabbable3 = containerRef.current.querySelectorAll(tababbleSelectors);
  const list = Array.prototype.filter.call(tabbable3, function(item) {
    return item.tabIndex >= "0";
  });
  return list;
}
function getNextIndex(index, position, collection) {
  let nextIndex;
  if (position === "up") {
    if (index === 0) {
      nextIndex = collection.length - 1;
    } else {
      nextIndex = index - 1;
    }
  } else if (index === collection.length - 1) {
    nextIndex = 0;
  } else {
    nextIndex = index + 1;
  }
  if (collection[nextIndex] === void 0 || collection[nextIndex][0] === null) {
    return getNextIndex(nextIndex, position, collection);
  } else {
    return nextIndex;
  }
}
function pluralize(i, singular, plural) {
  if (!plural) {
    plural = `${singular}s`;
  }
  return `${i || 0} ${i === 1 ? singular : plural}`;
}
var setBreakpointCssVars = (mods, cssVar) => Object.entries(mods || {}).reduce((acc, [breakpoint, value]) => breakpoint === "default" ? Object.assign(Object.assign({}, acc), { [cssVar]: value }) : Object.assign(Object.assign({}, acc), { [`${cssVar}-on-${breakpoint}`]: value }), {});
var formatBreakpointMods = (mods, styles, stylePrefix = "", breakpoint, vertical) => {
  if (!mods) {
    return "";
  }
  if (breakpoint && !vertical) {
    if (breakpoint in mods) {
      return styles.modifiers[toCamel(`${stylePrefix}${mods[breakpoint]}`)];
    }
    const breakpointsOrder = ["2xl", "xl", "lg", "md", "sm", "default"];
    const breakpointsIndex = breakpointsOrder.indexOf(breakpoint);
    for (let i = breakpointsIndex; i < breakpointsOrder.length; i++) {
      if (breakpointsOrder[i] in mods) {
        return styles.modifiers[toCamel(`${stylePrefix}${mods[breakpointsOrder[i]]}`)];
      }
    }
    return "";
  }
  return Object.entries(mods || {}).map(([breakpoint2, mod]) => `${stylePrefix}${mod}${breakpoint2 !== "default" ? `-on-${breakpoint2}` : ""}${vertical && breakpoint2 !== "default" ? "-height" : ""}`).map(toCamel).map((mod) => mod.replace(/-?(\dxl)/gi, (_res, group) => `_${group}`)).map((modifierKey) => styles.modifiers[modifierKey]).filter(Boolean).join(" ");
};
var getVerticalBreakpoint = (height) => {
  if (height === null) {
    return null;
  }
  if (height >= globalHeightBreakpoints["2xl"]) {
    return "2xl";
  }
  if (height >= globalHeightBreakpoints.xl) {
    return "xl";
  }
  if (height >= globalHeightBreakpoints.lg) {
    return "lg";
  }
  if (height >= globalHeightBreakpoints.md) {
    return "md";
  }
  if (height >= globalHeightBreakpoints.sm) {
    return "sm";
  }
  return "default";
};
var getBreakpoint = (width) => {
  if (width === null) {
    return null;
  }
  if (width >= globalWidthBreakpoints["2xl"]) {
    return "2xl";
  }
  if (width >= globalWidthBreakpoints.xl) {
    return "xl";
  }
  if (width >= globalWidthBreakpoints.lg) {
    return "lg";
  }
  if (width >= globalWidthBreakpoints.md) {
    return "md";
  }
  if (width >= globalWidthBreakpoints.sm) {
    return "sm";
  }
  return "default";
};
var camelize = (s) => s.toUpperCase().replace("-", "").replace("_", "");
var toCamel = (s) => s.replace(/([-_][a-z])/gi, camelize);
var canUseDOM = !!(typeof window !== "undefined" && window.document && window.document.createElement);
var getTextWidth = (text, node) => {
  const computedStyle = getComputedStyle(node);
  const getFontFromComputedStyle = () => {
    let computedFont = "";
    const fontStretchLookupTable = {
      "50%": "ultra-condensed",
      "62.5%": "extra-condensed",
      "75%": "condensed",
      "87.5%": "semi-condensed",
      "100%": "normal",
      "112.5%": "semi-expanded",
      "125%": "expanded",
      "150%": "extra-expanded",
      "200%": "ultra-expanded"
    };
    let fontStretch;
    if (computedStyle.fontStretch in fontStretchLookupTable) {
      fontStretch = fontStretchLookupTable[computedStyle.fontStretch];
    } else {
      fontStretch = "normal";
    }
    computedFont = computedStyle.fontStyle + " " + computedStyle.fontVariant + " " + computedStyle.fontWeight + " " + fontStretch + " " + computedStyle.fontSize + "/" + computedStyle.lineHeight + " " + computedStyle.fontFamily;
    return computedFont;
  };
  const canvas = document.createElement("canvas");
  const context = canvas.getContext("2d");
  context.font = computedStyle.font || getFontFromComputedStyle();
  return context.measureText(text).width;
};
var innerDimensions = (node) => {
  const computedStyle = getComputedStyle(node);
  let width = node.clientWidth;
  let height = node.clientHeight;
  height -= parseFloat(computedStyle.paddingTop) + parseFloat(computedStyle.paddingBottom);
  width -= parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);
  return { height, width };
};
var trimLeft = (node, value) => {
  const availableWidth = innerDimensions(node).width;
  let newValue = value;
  if (getTextWidth(value, node) > availableWidth) {
    while (getTextWidth(`...${newValue}`, node) > availableWidth) {
      newValue = newValue.substring(1);
    }
    if (node.value) {
      node.value = `...${newValue}`;
    } else {
      node.innerText = `...${newValue}`;
    }
  } else {
    if (node.value) {
      node.value = value;
    } else {
      node.innerText = value;
    }
  }
};
var preventedEvents = (events) => events.reduce((handlers, eventToPrevent) => Object.assign(Object.assign({}, handlers), { [eventToPrevent]: (event) => {
  event.preventDefault();
} }), {});
var clearTimeouts = (timeoutRefs) => {
  timeoutRefs.forEach((ref) => {
    if (ref.current) {
      clearTimeout(ref.current);
    }
  });
};
var getLanguageDirection = (targetElement, defaultDirection = "ltr") => {
  if (!targetElement) {
    return defaultDirection;
  }
  const computedDirection = getComputedStyle(targetElement).getPropertyValue("direction");
  if (["ltr", "rtl"].includes(computedDirection)) {
    return computedDirection;
  }
  return defaultDirection;
};
var getReferenceElement = (refProp) => {
  if (refProp instanceof HTMLElement) {
    return refProp;
  }
  if (typeof refProp === "function") {
    return refProp();
  }
  return refProp === null || refProp === void 0 ? void 0 : refProp.current;
};
var getInlineStartProperty = (targetElement, ancestorElement, inlineType = "offset") => {
  if (!targetElement) {
    return;
  }
  const inlineProperty = `${inlineType}Left`;
  const isRTL = getLanguageDirection(targetElement) === "rtl";
  if (!isRTL) {
    return targetElement[inlineProperty];
  }
  const widthProperty = `${inlineType}Width`;
  return ancestorElement[widthProperty] - (targetElement[inlineProperty] + targetElement[widthProperty]);
};

// node_modules/@patternfly/react-core/dist/esm/helpers/GenerateId/GenerateId.js
var import_react3 = __toESM(require_react());
var currentId = 0;
function getRandomId() {
  if (typeof crypto !== "undefined" && crypto.randomUUID) {
    return crypto.randomUUID();
  } else {
    return getUniqueId();
  }
}
var GenerateId = class extends import_react3.Component {
  constructor() {
    super(...arguments);
    this.uniqueElement = this.props.isRandom ? getRandomId() : currentId++;
    this.id = `${this.props.prefix}${this.uniqueElement}`;
  }
  render() {
    return this.props.children(this.id);
  }
};
GenerateId.displayName = "GenerateId";
GenerateId.defaultProps = {
  prefix: "pf-random-id-",
  isRandom: false
};

// node_modules/@patternfly/react-core/dist/esm/helpers/htmlConstants.js
var ASTERISK = "*";

// node_modules/@patternfly/react-core/dist/esm/helpers/OUIA/ouia.js
var import_react4 = __toESM(require_react());
var uid = 0;
var ouiaPrefix = "OUIA-Generated-";
var ouiaIdByRoute = {};
function getOUIAProps(componentType, id, ouiaSafe = true) {
  return {
    "data-ouia-component-type": `PF6/${componentType}`,
    "data-ouia-safe": ouiaSafe,
    "data-ouia-component-id": id
  };
}
var useOUIAProps = (componentType, id, ouiaSafe = true, variant) => ({
  "data-ouia-component-type": `PF6/${componentType}`,
  "data-ouia-safe": ouiaSafe,
  "data-ouia-component-id": useOUIAId(componentType, id, variant)
});
var useOUIAId = (componentType, id, variant) => {
  const defaultOUIAId = (0, import_react4.useMemo)(() => getDefaultOUIAId(componentType, variant), [componentType, variant]);
  return id !== null && id !== void 0 ? id : defaultOUIAId;
};
function getDefaultOUIAId(componentType, variant) {
  try {
    let key;
    if (typeof window !== "undefined") {
      key = `${window.location.href}-${componentType}-${variant || ""}`;
    } else {
      key = `${componentType}-${variant || ""}`;
    }
    if (!ouiaIdByRoute[key]) {
      ouiaIdByRoute[key] = 0;
    }
    return `${ouiaPrefix}${componentType}-${variant ? `${variant}-` : ""}${++ouiaIdByRoute[key]}`;
  } catch (exception) {
    return `${ouiaPrefix}${componentType}-${variant ? `${variant}-` : ""}${++uid}`;
  }
}

// node_modules/@patternfly/react-core/dist/esm/helpers/useIsomorphicLayout.js
var import_react5 = __toESM(require_react());
var useIsomorphicLayoutEffect = canUseDOM ? import_react5.useLayoutEffect : import_react5.useEffect;

// node_modules/@patternfly/react-core/dist/esm/helpers/Popper/Popper.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime());
var import_react7 = __toESM(require_react());
var ReactDOM = __toESM(require_react_dom());

// node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/react-popper/usePopper.js
var import_react6 = __toESM(require_react());

// node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/dom-utils/getBoundingClientRect.js
function getBoundingClientRect(element) {
  const rect = element.getBoundingClientRect();
  return {
    width: rect.width,
    height: rect.height,
    top: rect.top,
    right: rect.right,
    bottom: rect.bottom,
    left: rect.left,
    x: rect.left,
    y: rect.top
  };
}

// node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/dom-utils/getWindow.js
function getWindow(node) {
  if (node.toString() !== "[object Window]") {
    const ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView : window;
  }
  return node;
}

// node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/dom-utils/getWindowScroll.js
function getWindowScroll(node) {
  const win = getWindow(node);
  const scrollLeft = win.pageXOffset;
  const scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}

// node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/dom-utils/instanceOf.js
function isElement(node) {
  const OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  const OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}

// node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/dom-utils/getHTMLElementScroll.js
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}

// node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/dom-utils/getNodeScroll.js
function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}

// node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/dom-utils/getNodeName.js
function getNodeName(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}

// node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/dom-utils/getDocumentElement.js
function getDocumentElement(element) {
  return (isElement(element) ? element.ownerDocument : element.document).documentElement;
}

// node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/dom-utils/getWindowScrollBarX.js
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}

// node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/dom-utils/getComputedStyle.js
function getComputedStyle2(element) {
  return getWindow(element).getComputedStyle(element);
}

// node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/dom-utils/isScrollParent.js
function isScrollParent(element) {
  const { overflow, overflowX, overflowY } = getComputedStyle2(element);
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

// node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/dom-utils/getCompositeRect.js
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed = false) {
  const documentElement = getDocumentElement(offsetParent);
  const rect = getBoundingClientRect(elementOrVirtualElement);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  let scroll = { scrollLeft: 0, scrollTop: 0 };
  let offsets = { x: 0, y: 0 };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

// node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/dom-utils/getLayoutRect.js
function getLayoutRect(element) {
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width: element.offsetWidth,
    height: element.offsetHeight
  };
}

// node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/dom-utils/getParentNode.js
function getParentNode(element) {
  if (getNodeName(element) === "html") {
    return element;
  }
  return (
    // $FlowFixMe: this is a quicker (but less type safe) way to save quite some bytes from the bundle
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || // DOM Element detected
    // $FlowFixMe: need a better way to handle this...
    element.host || // ShadowRoot detected
    // $FlowFixMe: HTMLElement is a Node
    getDocumentElement(element)
  );
}

// node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/dom-utils/getScrollParent.js
function getScrollParent(node) {
  if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}

// node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/dom-utils/listScrollParents.js
function listScrollParents(element, list = []) {
  const scrollParent = getScrollParent(element);
  const isBody = getNodeName(scrollParent) === "body";
  const win = getWindow(scrollParent);
  const target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  const updatedList = list.concat(target);
  return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)));
}

// node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/dom-utils/isTableElement.js
function isTableElement(element) {
  return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
}

// node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/dom-utils/getOffsetParent.js
function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle2(element).position === "fixed") {
    return null;
  }
  const offsetParent = element.offsetParent;
  if (offsetParent) {
    const html = getDocumentElement(offsetParent);
    if (getNodeName(offsetParent) === "body" && getComputedStyle2(offsetParent).position === "static" && getComputedStyle2(html).position !== "static") {
      return html;
    }
  }
  return offsetParent;
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    const css2 = getComputedStyle2(currentNode);
    if (css2.transform !== "none" || css2.perspective !== "none" || css2.willChange && css2.willChange !== "auto") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  const window2 = getWindow(element);
  let offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle2(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && getNodeName(offsetParent) === "body" && getComputedStyle2(offsetParent).position === "static") {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}

// node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/enums.js
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = basePlacements.reduce((acc, placement) => acc.concat([`${placement}-${start}`, `${placement}-${end}`]), []);
var placements = [...basePlacements, auto].reduce((acc, placement) => acc.concat([placement, `${placement}-${start}`, `${placement}-${end}`]), []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [
  beforeRead,
  read,
  afterRead,
  beforeMain,
  main,
  afterMain,
  beforeWrite,
  write,
  afterWrite
];

// node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/utils/orderModifiers.js
function order(modifiers) {
  const map = /* @__PURE__ */ new Map();
  const visited = /* @__PURE__ */ new Set();
  const result = [];
  modifiers.forEach((modifier) => {
    map.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    const requires = [...modifier.requires || [], ...modifier.requiresIfExists || []];
    requires.forEach((dep) => {
      if (!visited.has(dep)) {
        const depModifier = map.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach((modifier) => {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  const orderedModifiers = order(modifiers);
  return modifierPhases.reduce((acc, phase) => acc.concat(orderedModifiers.filter((modifier) => modifier.phase === phase)), []);
}

// node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/utils/debounce.js
function debounce2(fn) {
  let pending;
  return () => {
    if (!pending) {
      pending = new Promise((resolve) => {
        Promise.resolve().then(() => {
          pending = void 0;
          resolve(fn());
        });
      });
    }
    return pending;
  };
}

// node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/utils/getBasePlacement.js
function getBasePlacement(placement) {
  return placement.split("-")[0];
}

// node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/utils/mergeByName.js
function mergeByName(modifiers) {
  const merged = modifiers.reduce((merged2, current) => {
    const existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign(Object.assign(Object.assign({}, existing), current), { options: Object.assign(Object.assign({}, existing.options), current.options), data: Object.assign(Object.assign({}, existing.data), current.data) }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map((key) => merged[key]);
}

// node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/dom-utils/getViewportRect.js
function getViewportRect(element) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x + getWindowScrollBarX(element),
    y
  };
}

// node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/dom-utils/getDocumentRect.js
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const winScroll = getWindowScroll(element);
  const body = element.ownerDocument.body;
  const width = Math.max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  const height = Math.max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  let x = -winScroll.scrollLeft + getWindowScrollBarX(element);
  const y = -winScroll.scrollTop;
  if (getComputedStyle2(body || html).direction === "rtl") {
    x += Math.max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return { width, height, x, y };
}

// node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/dom-utils/contains.js
function contains(parent, child) {
  const isShadow = Boolean(child.getRootNode && child.getRootNode().host);
  if (parent.contains(child)) {
    return true;
  } else if (isShadow) {
    let next = child;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}

// node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/utils/rectToClientRect.js
function rectToClientRect(rect) {
  return Object.assign(Object.assign({}, rect), { left: rect.x, top: rect.y, right: rect.x + rect.width, bottom: rect.y + rect.height });
}

// node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/dom-utils/getClippingRect.js
function getInnerBoundingClientRect(element) {
  const rect = getBoundingClientRect(element);
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isHTMLElement(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingParents(element) {
  const clippingParents2 = listScrollParents(getParentNode(element));
  const canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle2(element).position) >= 0;
  const clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingParents2.filter((clippingParent) => isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body");
}
function getClippingRect(element, boundary, rootBoundary) {
  const mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  const clippingParents2 = [...mainClippingParents, rootBoundary];
  const firstClippingParent = clippingParents2[0];
  const clippingRect = clippingParents2.reduce((accRect, clippingParent) => {
    const rect = getClientRectFromMixedType(element, clippingParent);
    accRect.top = Math.max(rect.top, accRect.top);
    accRect.right = Math.min(rect.right, accRect.right);
    accRect.bottom = Math.min(rect.bottom, accRect.bottom);
    accRect.left = Math.max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

// node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/utils/getVariation.js
function getVariation(placement) {
  return placement.split("-")[1];
}

// node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/utils/getMainAxisFromPlacement.js
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}

// node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/utils/computeOffsets.js
function computeOffsets({ reference: reference2, element, placement }) {
  const basePlacement = placement ? getBasePlacement(placement) : null;
  const variation = placement ? getVariation(placement) : null;
  const commonX = reference2.x + reference2.width / 2 - element.width / 2;
  const commonY = reference2.y + reference2.height / 2 - element.height / 2;
  let offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  const mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    const len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = Math.floor(offsets[mainAxis]) - Math.floor(reference2[len] / 2 - element[len] / 2);
        break;
      case end:
        offsets[mainAxis] = Math.floor(offsets[mainAxis]) + Math.ceil(reference2[len] / 2 - element[len] / 2);
        break;
      default:
    }
  }
  return offsets;
}

// node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/utils/getFreshSideObject.js
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

// node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/utils/mergePaddingObject.js
function mergePaddingObject(paddingObject) {
  return Object.assign(Object.assign({}, getFreshSideObject()), paddingObject);
}

// node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/utils/expandToHashMap.js
function expandToHashMap(value, keys) {
  return keys.reduce((hashMap, key) => {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

// node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/utils/detectOverflow.js
function detectOverflow(state, options = {}) {
  const { placement = state.placement, boundary = clippingParents, rootBoundary = viewport, elementContext = popper, altBoundary = false, padding = 0 } = options;
  const paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  const altContext = elementContext === popper ? reference : popper;
  const referenceElement = state.elements.reference;
  const popperRect = state.rects.popper;
  const element = state.elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);
  const referenceClientRect = getBoundingClientRect(referenceElement);
  const popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  const popperClientRect = rectToClientRect(Object.assign(Object.assign({}, popperRect), popperOffsets2));
  const elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  const overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  const offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    const offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach((key) => {
      const multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      const axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}

// node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/index.js
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements(...args) {
  return !args.some((element) => !(element && typeof element.getBoundingClientRect === "function"));
}
function popperGenerator(generatorOptions = {}) {
  const { defaultModifiers: defaultModifiers2 = [], defaultOptions = DEFAULT_OPTIONS } = generatorOptions;
  return function createPopper3(reference2, popper2, options = defaultOptions) {
    let state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign(Object.assign({}, DEFAULT_OPTIONS), defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    let effectCleanupFns = [];
    let isDestroyed = false;
    const instance = {
      state,
      setOptions(options2) {
        cleanupModifierEffects();
        state.options = Object.assign(Object.assign(Object.assign({}, defaultOptions), state.options), options2);
        state.scrollParents = {
          reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        const orderedModifiers = orderModifiers(mergeByName([...defaultModifiers2, ...state.options.modifiers]));
        state.orderedModifiers = orderedModifiers.filter((m) => m.enabled);
        if (false) {
          const modifiers = uniqueBy([...orderedModifiers, ...state.options.modifiers], ({ name }) => name);
          validateModifiers(modifiers);
          if (getBasePlacement(state.options.placement) === auto) {
            const flipModifier = state.orderedModifiers.find(({ name }) => name === "flip");
            if (!flipModifier) {
              console.error(['Popper: "auto" placements require the "flip" modifier be', "present and enabled to work."].join(" "));
            }
          }
          const { marginTop, marginRight, marginBottom, marginLeft } = getComputedStyle2(popper2);
          if ([marginTop, marginRight, marginBottom, marginLeft].some((margin) => parseFloat(margin))) {
            console.warn([
              'Popper: CSS "margin" styles cannot be used to apply padding',
              "between the popper and its reference element or boundary.",
              "To replicate margin, use the `offset` modifier, as well as",
              "the `padding` option in the `preventOverflow` and `flip`",
              "modifiers."
            ].join(" "));
          }
        }
        runModifierEffects();
        return instance.update();
      },
      // Sync update  it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate() {
        if (isDestroyed) {
          return;
        }
        const { reference: reference3, popper: popper3 } = state.elements;
        if (!areValidElements(reference3, popper3)) {
          if (false) {
            console.error(INVALID_ELEMENT_ERROR);
          }
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach((modifier) => state.modifiersData[modifier.name] = Object.assign({}, modifier.data));
        let __debug_loops__ = 0;
        for (let index = 0; index < state.orderedModifiers.length; index++) {
          if (false) {
            __debug_loops__ += 1;
            if (__debug_loops__ > 100) {
              console.error(INFINITE_LOOP_ERROR);
              break;
            }
          }
          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }
          const { fn, options: options2 = {}, name } = state.orderedModifiers[index];
          if (typeof fn === "function") {
            state = fn({ state, options: options2, name, instance }) || state;
          }
        }
      },
      // Async and optimistically optimized update  it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce2(() => new Promise((resolve) => {
        instance.forceUpdate();
        resolve(state);
      })),
      destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      if (false) {
        console.error(INVALID_ELEMENT_ERROR);
      }
      return instance;
    }
    instance.setOptions(options).then((state2) => {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(({ name, options: options2 = {}, effect: effect4 }) => {
        if (typeof effect4 === "function") {
          const cleanupFn = effect4({ state, name, instance, options: options2 });
          const noopFn = () => {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach((fn) => fn());
      effectCleanupFns = [];
    }
    return instance;
  };
}
var createPopper = popperGenerator();

// node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/modifiers/eventListeners.js
var passive = { passive: true };
function effect({ state, instance, options }) {
  const { scroll = true, resize = true } = options;
  const window2 = getWindow(state.elements.popper);
  const scrollParents = [...state.scrollParents.reference, ...state.scrollParents.popper];
  if (scroll) {
    scrollParents.forEach((scrollParent) => {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return () => {
    if (scroll) {
      scrollParents.forEach((scrollParent) => {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
var eventListeners_default = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: () => {
  },
  effect,
  data: {}
};

// node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/modifiers/popperOffsets.js
function popperOffsets({ state, name }) {
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
var popperOffsets_default = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};

// node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/modifiers/computeStyles.js
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsets({ x, y }) {
  const win = window;
  const dpr = win.devicePixelRatio || 1;
  return {
    x: Math.round(x * dpr) / dpr || 0,
    y: Math.round(y * dpr) / dpr || 0
  };
}
function mapToStyles({ popper: popper2, popperRect, placement, offsets, position, gpuAcceleration, adaptive }) {
  let { x, y } = roundOffsets(offsets);
  const hasX = offsets.hasOwnProperty("x");
  const hasY = offsets.hasOwnProperty("y");
  let sideX = left;
  let sideY = top;
  const win = window;
  if (adaptive) {
    let offsetParent = getOffsetParent(popper2);
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
    }
    if (placement === top) {
      sideY = bottom;
      y -= offsetParent.clientHeight - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left) {
      sideX = right;
      x -= offsetParent.clientWidth - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }
  const commonStyles = Object.assign({ position }, adaptive && unsetSides);
  if (gpuAcceleration) {
    return Object.assign(Object.assign({}, commonStyles), {
      [sideY]: hasY ? "0" : "",
      [sideX]: hasX ? "0" : "",
      // Layer acceleration can disable subpixel rendering which causes slightly
      // blurry text on low PPI displays, so we want to use 2D transforms
      // instead
      transform: (win.devicePixelRatio || 1) < 2 ? `translate(${x}px, ${y}px)` : `translate3d(${x}px, ${y}px, 0)`
    });
  }
  return Object.assign(Object.assign({}, commonStyles), { [sideY]: hasY ? `${y}px` : "", [sideX]: hasX ? `${x}px` : "", transform: "" });
}
function computeStyles({ state, options }) {
  const { gpuAcceleration = true, adaptive = true } = options;
  if (false) {
    const transitionProperty = getComputedStyle2(state.elements.popper).transitionProperty || "";
    if (adaptive && ["transform", "top", "right", "bottom", "left"].some((property) => transitionProperty.indexOf(property) >= 0)) {
      console.warn([
        "Popper: Detected CSS transitions on at least one of the following",
        'CSS properties: "transform", "top", "right", "bottom", "left".',
        "\n\n",
        'Disable the "computeStyles" modifier\'s `adaptive` option to allow',
        "for smooth transitions, or remove these properties from the CSS",
        "transition declaration on the popper element if only transitioning",
        "opacity or background-color for example.",
        "\n\n",
        "We recommend using the popper element as a wrapper around an inner",
        "element that can have any CSS property transitioned for animations."
      ].join(" "));
    }
  }
  const commonStyles = {
    placement: getBasePlacement(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign(Object.assign({}, state.styles.popper), mapToStyles(Object.assign(Object.assign({}, commonStyles), { offsets: state.modifiersData.popperOffsets, position: state.options.strategy, adaptive })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign(Object.assign({}, state.styles.arrow), mapToStyles(Object.assign(Object.assign({}, commonStyles), { offsets: state.modifiersData.arrow, position: "absolute", adaptive: false })));
  }
  state.attributes.popper = Object.assign(Object.assign({}, state.attributes.popper), { "data-popper-placement": state.placement });
}
var computeStyles_default = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};

// node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/modifiers/applyStyles.js
function applyStyles({ state }) {
  Object.keys(state.elements).forEach((name) => {
    const style = state.styles[name] || {};
    const attributes = state.attributes[name] || {};
    const element = state.elements[name];
    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    }
    Object.assign(element.style, style);
    Object.keys(attributes).forEach((name2) => {
      const value = attributes[name2];
      if (value === false) {
        element.removeAttribute(name2);
      } else {
        element.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect2({ state }) {
  const initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return () => {
    Object.keys(state.elements).forEach((name) => {
      const element = state.elements[name];
      const attributes = state.attributes[name] || {};
      const styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      const style = styleProperties.reduce((style2, property) => {
        style2[property] = "";
        return style2;
      }, {});
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach((attribute) => {
        element.removeAttribute(attribute);
      });
    });
  };
}
var applyStyles_default = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect: effect2,
  requires: ["computeStyles"]
};

// node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/modifiers/offset.js
function distanceAndSkiddingToXY(placement, rects, offset2) {
  const basePlacement = getBasePlacement(placement);
  const invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  let [skidding, distance] = typeof offset2 === "function" ? offset2(Object.assign(Object.assign({}, rects), { placement })) : offset2;
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? { x: distance, y: skidding } : { x: skidding, y: distance };
}
function offset({ state, options, name }) {
  const { offset: offset2 = [0, 0] } = options;
  const data = placements.reduce((acc, placement) => {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  const { x, y } = data[state.placement];
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }
  state.modifiersData[name] = data;
}
var offset_default = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};

// node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/utils/getOppositePlacement.js
var hash = { left: "right", right: "left", bottom: "top", top: "bottom" };
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (matched) => hash[matched]);
}

// node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/utils/getOppositeVariationPlacement.js
var hash2 = { start: "end", end: "start" };
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, (matched) => hash2[matched]);
}

// node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/utils/computeAutoPlacement.js
function computeAutoPlacement(state, options = {}) {
  const { placement, boundary, rootBoundary, padding, flipVariations, allowedAutoPlacements = placements } = options;
  const variation = getVariation(placement);
  const placements2 = variation ? flipVariations ? variationPlacements : variationPlacements.filter((placement2) => getVariation(placement2) === variation) : basePlacements;
  let allowedPlacements = placements2.filter((placement2) => allowedAutoPlacements.indexOf(placement2) >= 0);
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements2;
    if (false) {
      console.error([
        "Popper: The `allowedAutoPlacements` option did not allow any",
        "placements. Ensure the `placement` option matches the variation",
        "of the allowed placements.",
        'For example, "auto" cannot be used to allow "bottom-start".',
        'Use "auto-start" instead.'
      ].join(" "));
    }
  }
  const overflows = allowedPlacements.reduce((acc, placement2) => {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort((a, b) => overflows[a] - overflows[b]);
}

// node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/modifiers/flip.js
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  const oppositePlacement = getOppositePlacement(placement);
  return [
    getOppositeVariationPlacement(placement),
    oppositePlacement,
    getOppositeVariationPlacement(oppositePlacement)
  ];
}
function flip({ state, options, name }) {
  if (state.modifiersData[name]._skip) {
    return;
  }
  const { mainAxis: checkMainAxis = true, altAxis: checkAltAxis = true, fallbackPlacements: specifiedFallbackPlacements, padding, boundary, rootBoundary, altBoundary, flipVariations = true, allowedAutoPlacements } = options;
  const preferredPlacement = state.options.placement;
  const basePlacement = getBasePlacement(preferredPlacement);
  const isBasePlacement = basePlacement === preferredPlacement;
  const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  const placements2 = [preferredPlacement, ...fallbackPlacements].reduce((acc, placement) => acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {
    placement,
    boundary,
    rootBoundary,
    padding,
    flipVariations,
    allowedAutoPlacements
  }) : placement), []);
  const referenceRect = state.rects.reference;
  const popperRect = state.rects.popper;
  const checksMap = /* @__PURE__ */ new Map();
  let makeFallbackChecks = true;
  let firstFittingPlacement = placements2[0];
  for (let i = 0; i < placements2.length; i++) {
    const placement = placements2[i];
    const basePlacement2 = getBasePlacement(placement);
    const isStartVariation = getVariation(placement) === start;
    const isVertical = [top, bottom].indexOf(basePlacement2) >= 0;
    const len = isVertical ? "width" : "height";
    const overflow = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    let mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    const altVariationSide = getOppositePlacement(mainVariationSide);
    const checks = [];
    if (checkMainAxis) {
      checks.push(overflow[basePlacement2] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every((check) => check)) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    const numberOfChecks = flipVariations ? 3 : 1;
    for (let i = numberOfChecks; i > 0; i--) {
      const fittingPlacement = placements2.find((placement) => {
        const checks = checksMap.get(placement);
        if (checks) {
          return checks.slice(0, i).every((check) => check);
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        break;
      }
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
var flip_default = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: { _skip: false }
};

// node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/utils/getAltAxis.js
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}

// node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/utils/within.js
function within(min, value, max) {
  return Math.max(min, Math.min(value, max));
}

// node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/modifiers/preventOverflow.js
function preventOverflow({ state, options, name }) {
  const { mainAxis: checkMainAxis = true, altAxis: checkAltAxis = false, boundary, rootBoundary, altBoundary, padding, tether = true, tetherOffset = 0 } = options;
  const overflow = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  const basePlacement = getBasePlacement(state.placement);
  const variation = getVariation(state.placement);
  const isBasePlacement = !variation;
  const mainAxis = getMainAxisFromPlacement(basePlacement);
  const altAxis = getAltAxis(mainAxis);
  const popperOffsets2 = state.modifiersData.popperOffsets;
  const referenceRect = state.rects.reference;
  const popperRect = state.rects.popper;
  const tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign(Object.assign({}, state.rects), { placement: state.placement })) : tetherOffset;
  const data = { x: 0, y: 0 };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    const mainSide = mainAxis === "y" ? top : left;
    const altSide = mainAxis === "y" ? bottom : right;
    const len = mainAxis === "y" ? "height" : "width";
    const offset2 = popperOffsets2[mainAxis];
    const min = popperOffsets2[mainAxis] + overflow[mainSide];
    const max = popperOffsets2[mainAxis] - overflow[altSide];
    const additive = tether ? -popperRect[len] / 2 : 0;
    const minLen = variation === start ? referenceRect[len] : popperRect[len];
    const maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    const arrowElement = state.elements.arrow;
    const arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : { width: 0, height: 0 };
    const arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    const arrowPaddingMin = arrowPaddingObject[mainSide];
    const arrowPaddingMax = arrowPaddingObject[altSide];
    const arrowLen = within(0, referenceRect[len], arrowRect[len]);
    const minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - tetherOffsetValue : minLen - arrowLen - arrowPaddingMin - tetherOffsetValue;
    const maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + tetherOffsetValue : maxLen + arrowLen + arrowPaddingMax + tetherOffsetValue;
    const arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    const clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    const offsetModifierValue = state.modifiersData.offset ? state.modifiersData.offset[state.placement][mainAxis] : 0;
    const tetherMin = popperOffsets2[mainAxis] + minOffset - offsetModifierValue - clientOffset;
    const tetherMax = popperOffsets2[mainAxis] + maxOffset - offsetModifierValue;
    const preventedOffset = within(tether ? Math.min(min, tetherMin) : min, offset2, tether ? Math.max(max, tetherMax) : max);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    const mainSide = mainAxis === "x" ? top : left;
    const altSide = mainAxis === "x" ? bottom : right;
    const offset2 = popperOffsets2[altAxis];
    const min = offset2 + overflow[mainSide];
    const max = offset2 - overflow[altSide];
    const preventedOffset = within(min, offset2, max);
    popperOffsets2[altAxis] = preventedOffset;
    data[altAxis] = preventedOffset - offset2;
  }
  state.modifiersData[name] = data;
}
var preventOverflow_default = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};

// node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/modifiers/arrow.js
function arrow({ state, name }) {
  const arrowElement = state.elements.arrow;
  const popperOffsets2 = state.modifiersData.popperOffsets;
  const basePlacement = getBasePlacement(state.placement);
  const axis = getMainAxisFromPlacement(basePlacement);
  const isVertical = [left, right].indexOf(basePlacement) >= 0;
  const len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  const paddingObject = state.modifiersData[`${name}#persistent`].padding;
  const arrowRect = getLayoutRect(arrowElement);
  const minProp = axis === "y" ? top : left;
  const maxProp = axis === "y" ? bottom : right;
  const endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  const startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  const arrowOffsetParent = getOffsetParent(arrowElement);
  const clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  const centerToReference = endDiff / 2 - startDiff / 2;
  const min = paddingObject[minProp];
  const max = clientSize - arrowRect[len] - paddingObject[maxProp];
  const center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  const offset2 = within(min, center, max);
  const axisProp = axis;
  state.modifiersData[name] = {
    [axisProp]: offset2,
    centerOffset: offset2 - center
  };
}
function effect3({ state, options, name }) {
  let { element: arrowElement = "[data-popper-arrow]", padding = 0 } = options;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (false) {
    if (!isHTMLElement(arrowElement)) {
      console.error([
        'Popper: "arrow" element must be an HTMLElement (not an SVGElement).',
        "To use an SVG arrow, wrap it in an HTMLElement that will be used as",
        "the arrow."
      ].join(" "));
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    if (false) {
      console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', "element."].join(" "));
    }
    return;
  }
  state.elements.arrow = arrowElement;
  state.modifiersData[`${name}#persistent`] = {
    padding: mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements))
  };
}
var arrow_default = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect3,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};

// node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/modifiers/hide.js
function getSideOffsets(overflow, rect, preventedOffsets = { x: 0, y: 0 }) {
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some((side) => overflow[side] >= 0);
}
function hide({ state, name }) {
  const referenceRect = state.rects.reference;
  const popperRect = state.rects.popper;
  const preventedOffsets = state.modifiersData.preventOverflow;
  const referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  const popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  const referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  const popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  const isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  const hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign(Object.assign({}, state.attributes.popper), { "data-popper-reference-hidden": isReferenceHidden, "data-popper-escaped": hasPopperEscaped });
}
var hide_default = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};

// node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/popper-core/popper.js
var defaultModifiers = [
  eventListeners_default,
  popperOffsets_default,
  computeStyles_default,
  applyStyles_default,
  offset_default,
  flip_default,
  preventOverflow_default,
  arrow_default,
  hide_default
];
var createPopper2 = popperGenerator({ defaultModifiers });

// node_modules/@patternfly/react-core/dist/esm/helpers/Popper/thirdparty/react-popper/usePopper.js
var isEqual = (a, b) => JSON.stringify(a) === JSON.stringify(b);
var fromEntries = (entries) => entries.reduce((acc, [key, value]) => {
  acc[key] = value;
  return acc;
}, {});
var EMPTY_MODIFIERS = [];
var usePopper = (referenceElement, popperElement, options = {}) => {
  const prevOptions = (0, import_react6.useRef)(null);
  const optionsWithDefaults = {
    onFirstUpdate: options.onFirstUpdate,
    placement: options.placement || "bottom",
    strategy: options.strategy || "absolute",
    modifiers: options.modifiers || EMPTY_MODIFIERS
  };
  const [state, setState] = (0, import_react6.useState)({
    styles: {
      popper: {
        position: optionsWithDefaults.strategy,
        left: "0",
        top: "0"
      }
    },
    attributes: {}
  });
  const updateStateModifier = (0, import_react6.useMemo)(() => ({
    name: "updateState",
    enabled: true,
    phase: "write",
    // eslint-disable-next-line no-shadow
    fn: ({ state: state2 }) => {
      const elements = Object.keys(state2.elements);
      setState({
        styles: fromEntries(elements.map((element) => [element, state2.styles[element] || {}])),
        attributes: fromEntries(elements.map((element) => [element, state2.attributes[element]]))
      });
    },
    requires: ["computeStyles"]
  }), []);
  const popperOptions = (0, import_react6.useMemo)(() => {
    const newOptions = {
      onFirstUpdate: optionsWithDefaults.onFirstUpdate,
      placement: optionsWithDefaults.placement,
      strategy: optionsWithDefaults.strategy,
      modifiers: [...optionsWithDefaults.modifiers, updateStateModifier, { name: "applyStyles", enabled: false }]
    };
    if (isEqual(prevOptions.current, newOptions)) {
      return prevOptions.current || newOptions;
    } else {
      prevOptions.current = newOptions;
      return newOptions;
    }
  }, [
    optionsWithDefaults.onFirstUpdate,
    optionsWithDefaults.placement,
    optionsWithDefaults.strategy,
    optionsWithDefaults.modifiers,
    updateStateModifier
  ]);
  const popperInstanceRef = (0, import_react6.useRef)(void 0);
  useIsomorphicLayoutEffect(() => {
    if (popperInstanceRef && popperInstanceRef.current) {
      popperInstanceRef.current.setOptions(popperOptions);
    }
  }, [popperOptions]);
  useIsomorphicLayoutEffect(() => {
    if (referenceElement == null || popperElement == null) {
      return;
    }
    const createPopper3 = options.createPopper || createPopper2;
    const popperInstance = createPopper3(referenceElement, popperElement, popperOptions);
    popperInstanceRef.current = popperInstance;
    return () => {
      popperInstance.destroy();
      popperInstanceRef.current = null;
    };
  }, [referenceElement, popperElement, options.createPopper]);
  return {
    state: popperInstanceRef.current ? popperInstanceRef.current.state : null,
    styles: state.styles,
    attributes: state.attributes,
    update: popperInstanceRef.current ? popperInstanceRef.current.update : null,
    forceUpdate: popperInstanceRef.current ? popperInstanceRef.current.forceUpdate : null
  };
};

// node_modules/@patternfly/react-styles/dist/esm/index.js
function css(...args) {
  const classes = [];
  const hasOwn = {}.hasOwnProperty;
  args.filter(Boolean).forEach((arg) => {
    const argType = typeof arg;
    if (argType === "string" || argType === "number") {
      classes.push(arg);
    } else if (Array.isArray(arg) && arg.length) {
      const inner = css(...arg);
      if (inner) {
        classes.push(inner);
      }
    } else if (argType === "object") {
      for (const key in arg) {
        if (hasOwn.call(arg, key) && arg[key]) {
          classes.push(key);
        }
      }
    }
  });
  return classes.join(" ");
}

// node_modules/@patternfly/react-core/dist/esm/helpers/Popper/Popper.js
import "/Users/pamparan/Desktop/Edge - AI Design support  /amplify-edge/frontend/node_modules/@patternfly/react-styles/css/components/Popper/Popper.css";
var hash3 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom",
  "top-start": "bottom-end",
  "top-end": "bottom-start",
  "bottom-start": "top-end",
  "bottom-end": "top-start",
  "left-start": "right-end",
  "left-end": "right-start",
  "right-start": "left-end",
  "right-end": "left-start"
};
var getOppositePlacement2 = (placement) => placement.replace(/left|right|bottom|top|top-start|top-end|bottom-start|bottom-end|right-start|right-end|left-start|left-end/g, (matched) => hash3[matched]);
var getOpacityTransition = (animationDuration) => `opacity ${animationDuration}ms cubic-bezier(.54, 1.5, .38, 1.11)`;
var Popper = ({ trigger, popper: popper2, direction = "down", position = "start", placement, width, minWidth = "trigger", maxWidth, appendTo = () => document.body, zIndex = 9999, isVisible = true, positionModifiers, distance = 0, onMouseEnter, onMouseLeave, onFocus, onBlur, onDocumentClick, onTriggerClick, onTriggerEnter, onPopperClick, onPopperMouseEnter, onPopperMouseLeave, onDocumentKeyDown, enableFlip = true, flipBehavior = "flip", triggerRef, popperRef, animationDuration = 0, entryDelay = 0, exitDelay = 0, onHidden = () => {
}, onHide = () => {
}, onMount = () => {
}, onShow = () => {
}, onShown = () => {
}, preventOverflow: preventOverflow2 = false }) => {
  var _a;
  const [triggerElement, setTriggerElement] = (0, import_react7.useState)(null);
  const [refElement, setRefElement] = (0, import_react7.useState)(null);
  const [popperElement, setPopperElement] = (0, import_react7.useState)(null);
  const [popperContent, setPopperContent] = (0, import_react7.useState)(null);
  const [ready, setReady] = (0, import_react7.useState)(false);
  const [opacity, setOpacity] = (0, import_react7.useState)(0);
  const [internalIsVisible, setInternalIsVisible] = (0, import_react7.useState)(isVisible);
  const transitionTimerRef = (0, import_react7.useRef)(null);
  const showTimerRef = (0, import_react7.useRef)(null);
  const hideTimerRef = (0, import_react7.useRef)(null);
  const prevExitDelayRef = (0, import_react7.useRef)(void 0);
  const refOrTrigger = refElement || triggerElement;
  const showPopper = isVisible || internalIsVisible;
  const triggerParent = (_a = (triggerRef === null || triggerRef === void 0 ? void 0 : triggerRef.current) || triggerElement) === null || _a === void 0 ? void 0 : _a.parentElement;
  const languageDirection = getLanguageDirection(triggerParent);
  const internalPosition = (0, import_react7.useMemo)(() => {
    const fixedPositions = { left: "left", right: "right", center: "center" };
    const positionMap = {
      ltr: Object.assign({ start: "left", end: "right" }, fixedPositions),
      rtl: Object.assign({ start: "right", end: "left" }, fixedPositions)
    };
    return positionMap[languageDirection][position];
  }, [position, languageDirection]);
  const onDocumentClickCallback = (0, import_react7.useCallback)((event) => onDocumentClick(event, refOrTrigger, popperElement), [showPopper, triggerElement, refElement, popperElement, onDocumentClick]);
  (0, import_react7.useEffect)(() => {
    setReady(true);
    onMount();
  }, []);
  (0, import_react7.useEffect)(() => () => {
    clearTimeouts([transitionTimerRef, hideTimerRef, showTimerRef]);
  }, []);
  (0, import_react7.useEffect)(() => {
    if (triggerRef) {
      if (triggerRef.current) {
        setRefElement(triggerRef.current);
      } else if (typeof triggerRef === "function") {
        setRefElement(triggerRef());
      }
    }
  }, [triggerRef, trigger]);
  (0, import_react7.useEffect)(() => {
    if (popperRef) {
      if (popperRef.current) {
        setPopperElement(popperRef.current);
      } else if (typeof popperRef === "function") {
        setPopperElement(popperRef());
      }
    }
  }, [showPopper, popperRef]);
  (0, import_react7.useEffect)(() => {
    const observer = new MutationObserver(() => {
      update && update();
    });
    popperElement && observer.observe(popperElement, { attributes: true, childList: true, subtree: true });
    return () => {
      observer.disconnect();
    };
  }, [popperElement]);
  const addEventListener = (listener, element, event, capture = false) => {
    if (listener && element) {
      element.addEventListener(event, listener, { capture });
    }
  };
  const removeEventListener = (listener, element, event, capture = false) => {
    if (listener && element) {
      element.removeEventListener(event, listener, { capture });
    }
  };
  (0, import_react7.useEffect)(() => {
    addEventListener(onMouseEnter, refOrTrigger, "mouseenter");
    addEventListener(onMouseLeave, refOrTrigger, "mouseleave");
    addEventListener(onFocus, refOrTrigger, "focus");
    addEventListener(onBlur, refOrTrigger, "blur");
    addEventListener(onTriggerClick, refOrTrigger, "click");
    addEventListener(onTriggerEnter, refOrTrigger, "keydown");
    addEventListener(onPopperClick, popperElement, "click");
    addEventListener(onPopperMouseEnter, popperElement, "mouseenter");
    addEventListener(onPopperMouseLeave, popperElement, "mouseleave");
    onDocumentClick && addEventListener(onDocumentClickCallback, document, "click", true);
    addEventListener(onDocumentKeyDown, document, "keydown", true);
    return () => {
      removeEventListener(onMouseEnter, refOrTrigger, "mouseenter");
      removeEventListener(onMouseLeave, refOrTrigger, "mouseleave");
      removeEventListener(onFocus, refOrTrigger, "focus");
      removeEventListener(onBlur, refOrTrigger, "blur");
      removeEventListener(onTriggerClick, refOrTrigger, "click");
      removeEventListener(onTriggerEnter, refOrTrigger, "keydown");
      removeEventListener(onPopperClick, popperElement, "click");
      removeEventListener(onPopperMouseEnter, popperElement, "mouseenter");
      removeEventListener(onPopperMouseLeave, popperElement, "mouseleave");
      onDocumentClick && removeEventListener(onDocumentClickCallback, document, "click", true);
      removeEventListener(onDocumentKeyDown, document, "keydown", true);
    };
  }, [
    triggerElement,
    popperElement,
    onMouseEnter,
    onMouseLeave,
    onFocus,
    onBlur,
    onTriggerClick,
    onTriggerEnter,
    onPopperClick,
    onPopperMouseEnter,
    onPopperMouseLeave,
    onDocumentClick,
    onDocumentKeyDown,
    refElement
  ]);
  const getPlacement = () => {
    if (placement) {
      return placement;
    }
    let convertedPlacement = direction === "up" ? "top" : "bottom";
    if (internalPosition !== "center") {
      convertedPlacement = `${convertedPlacement}-${internalPosition === "right" ? "end" : "start"}`;
    }
    return convertedPlacement;
  };
  const getPlacementMemo = (0, import_react7.useMemo)(getPlacement, [direction, internalPosition, placement]);
  const getOppositePlacementMemo = (0, import_react7.useMemo)(() => getOppositePlacement2(getPlacement()), [direction, internalPosition, placement]);
  const widthMods = (0, import_react7.useMemo)(() => ({
    name: "widthMods",
    enabled: width !== void 0 || minWidth !== void 0 || maxWidth !== void 0,
    phase: "beforeWrite",
    requires: ["computeStyles"],
    fn: ({ state }) => {
      const triggerWidth = state.rects.reference.width;
      if (width) {
        state.styles.popper.width = width === "trigger" ? `${triggerWidth}px` : width;
      }
      if (minWidth) {
        state.styles.popper.minWidth = minWidth === "trigger" ? `${triggerWidth}px` : minWidth;
      }
      if (maxWidth) {
        state.styles.popper.maxWidth = maxWidth === "trigger" ? `${triggerWidth}px` : maxWidth;
      }
    },
    effect: ({ state }) => {
      const triggerWidth = state.elements.reference.offsetWidth;
      if (width) {
        state.elements.popper.style.width = width === "trigger" ? `${triggerWidth}px` : width;
      }
      if (minWidth) {
        state.elements.popper.style.minWidth = minWidth === "trigger" ? `${triggerWidth}px` : minWidth;
      }
      if (maxWidth) {
        state.elements.popper.style.maxWidth = maxWidth === "trigger" ? `${triggerWidth}px` : maxWidth;
      }
      return () => {
      };
    }
  }), [width, minWidth, maxWidth]);
  const { styles: popperStyles, attributes, update, forceUpdate } = usePopper(refOrTrigger, popperElement, {
    placement: getPlacementMemo,
    modifiers: [
      {
        name: "offset",
        options: {
          offset: [0, distance]
        }
      },
      {
        name: "preventOverflow",
        enabled: preventOverflow2
      },
      {
        // adds attribute [data-popper-reference-hidden] to the popper element which can be used to hide it using CSS
        name: "hide",
        enabled: true
      },
      {
        name: "flip",
        enabled: getPlacementMemo.startsWith("auto") || enableFlip,
        options: {
          fallbackPlacements: flipBehavior === "flip" ? [getOppositePlacementMemo] : flipBehavior
        }
      },
      widthMods
    ]
  });
  (0, import_react7.useEffect)(() => {
    var _a2, _b, _c, _d, _e, _f, _g;
    const currentPopperContent = ((_d = (_c = (_b = (_a2 = popper2 === null || popper2 === void 0 ? void 0 : popper2.props) === null || _a2 === void 0 ? void 0 : _a2.children) === null || _b === void 0 ? void 0 : _b[1]) === null || _c === void 0 ? void 0 : _c.props) === null || _d === void 0 ? void 0 : _d.children) || ((_g = (_f = (_e = popper2 === null || popper2 === void 0 ? void 0 : popper2.props) === null || _e === void 0 ? void 0 : _e.children) === null || _f === void 0 ? void 0 : _f.props) === null || _g === void 0 ? void 0 : _g.children);
    setPopperContent(currentPopperContent);
    if (currentPopperContent && popperContent && currentPopperContent !== popperContent) {
      forceUpdate && forceUpdate();
    }
  }, [popper2]);
  (0, import_react7.useEffect)(() => {
    if (prevExitDelayRef.current < exitDelay) {
      clearTimeouts([transitionTimerRef, hideTimerRef]);
      hideTimerRef.current = setTimeout(() => {
        transitionTimerRef.current = setTimeout(() => {
          setInternalIsVisible(false);
        }, animationDuration);
      }, exitDelay);
    }
    prevExitDelayRef.current = exitDelay;
  }, [exitDelay]);
  const show = () => {
    onShow();
    clearTimeouts([transitionTimerRef, hideTimerRef]);
    showTimerRef.current = setTimeout(() => {
      setInternalIsVisible(true);
      setOpacity(1);
      onShown();
    }, entryDelay);
  };
  const hide2 = () => {
    onHide();
    clearTimeouts([showTimerRef]);
    hideTimerRef.current = setTimeout(() => {
      setOpacity(0);
      transitionTimerRef.current = setTimeout(() => {
        setInternalIsVisible(false);
        setPopperElement(null);
        onHidden();
      }, animationDuration);
    }, exitDelay);
  };
  (0, import_react7.useEffect)(() => {
    if (isVisible) {
      show();
    } else {
      hide2();
    }
  }, [isVisible]);
  const modifierFromPopperPosition = () => {
    if (attributes && attributes.popper && attributes.popper["data-popper-placement"]) {
      const popperPlacement = attributes.popper["data-popper-placement"];
      return positionModifiers[popperPlacement];
    }
    return positionModifiers.top;
  };
  const options = Object.assign({ className: css(popper2.props && popper2.props.className, positionModifiers && modifierFromPopperPosition()), style: Object.assign(Object.assign(Object.assign({}, popper2.props && popper2.props.style || {}), popperStyles.popper), {
    zIndex,
    opacity,
    transition: getOpacityTransition(animationDuration)
  }) }, attributes.popper);
  const getMenuWithPopper = () => {
    const localPopper = (0, import_react7.cloneElement)(popper2, options);
    return popperRef ? localPopper : (0, import_jsx_runtime2.jsx)("div", { style: { display: "contents" }, ref: (node) => {
      setPopperElement(node === null || node === void 0 ? void 0 : node.firstElementChild);
    }, children: localPopper });
  };
  const getPopper = () => {
    if (appendTo === "inline") {
      return getMenuWithPopper();
    } else {
      const target = typeof appendTo === "function" ? appendTo() : appendTo;
      return ReactDOM.createPortal(getMenuWithPopper(), target);
    }
  };
  return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [!triggerRef && trigger && (0, import_react7.isValidElement)(trigger) && (0, import_jsx_runtime2.jsx)("div", { style: { display: "contents" }, ref: (node) => {
    setTriggerElement(node === null || node === void 0 ? void 0 : node.firstElementChild);
  }, children: trigger }), triggerRef && trigger && (0, import_react7.isValidElement)(trigger) && trigger, ready && showPopper && getPopper()] });
};
Popper.displayName = "Popper";

// node_modules/@patternfly/react-core/dist/esm/helpers/KeyboardHandler.js
var import_react8 = __toESM(require_react());
var handleArrows = (event, navigableElements, isActiveElement = (element) => document.activeElement.contains(element), getFocusableElement = (element) => element, validSiblingTags = ["A", "BUTTON", "INPUT"], noVerticalArrowHandling = false, noHorizontalArrowHandling = false, updateTabIndex = true, onlyTraverseSiblings = true) => {
  const activeElement = document.activeElement;
  const key = event.key;
  let moveTarget = null;
  if (!noVerticalArrowHandling) {
    if (["ArrowUp", "ArrowDown"].includes(key)) {
      event.preventDefault();
      event.stopImmediatePropagation();
      let currentIndex = -1;
      navigableElements.forEach((element, index) => {
        if (isActiveElement(element)) {
          let increment = 0;
          while (!moveTarget && increment < navigableElements.length && increment * -1 < navigableElements.length) {
            key === "ArrowUp" ? increment-- : increment++;
            currentIndex = index + increment;
            if (currentIndex >= navigableElements.length) {
              currentIndex = 0;
            }
            if (currentIndex < 0) {
              currentIndex = navigableElements.length - 1;
            }
            moveTarget = getFocusableElement(navigableElements[currentIndex]);
          }
        }
      });
    }
  }
  if (!noHorizontalArrowHandling) {
    if (["ArrowLeft", "ArrowRight"].includes(key)) {
      event.preventDefault();
      event.stopImmediatePropagation();
      let currentIndex = -1;
      navigableElements.forEach((element, index) => {
        var _a;
        if (isActiveElement(element)) {
          const activeRow = navigableElements[index].querySelectorAll(validSiblingTags.join(","));
          if (!activeRow.length || onlyTraverseSiblings) {
            let nextSibling = activeElement;
            while (nextSibling) {
              const isDirectChildOfNavigableElement = nextSibling.parentElement === element;
              const nextSiblingMainElement = isDirectChildOfNavigableElement ? nextSibling : nextSibling.parentElement;
              nextSibling = key === "ArrowLeft" ? nextSiblingMainElement.previousElementSibling : nextSiblingMainElement.nextElementSibling;
              if (nextSibling) {
                if (validSiblingTags.includes(nextSibling === null || nextSibling === void 0 ? void 0 : nextSibling.tagName)) {
                  moveTarget = nextSibling;
                  break;
                }
                if (validSiblingTags.includes((_a = nextSibling.children[0]) === null || _a === void 0 ? void 0 : _a.tagName)) {
                  moveTarget = nextSibling.children[0];
                  break;
                }
              }
            }
          } else {
            activeRow.forEach((focusableElement, index2) => {
              if (event.target === focusableElement) {
                const increment = key === "ArrowLeft" ? -1 : 1;
                currentIndex = index2 + increment;
                if (currentIndex >= activeRow.length) {
                  currentIndex = 0;
                }
                if (currentIndex < 0) {
                  currentIndex = activeRow.length - 1;
                }
                moveTarget = activeRow[currentIndex];
              }
            });
          }
        }
      });
    }
  }
  if (moveTarget) {
    if (updateTabIndex) {
      activeElement.tabIndex = -1;
      moveTarget.tabIndex = 0;
    }
    moveTarget.focus();
  }
};
var setTabIndex = (options) => {
  if (options && options.length > 0) {
    options.forEach((option) => {
      option.tabIndex = -1;
    });
    options[0].tabIndex = 0;
  }
};
var onToggleArrowKeydownDefault = (event, menuRef) => {
  var _a;
  if (event.key !== "ArrowDown" && event.key !== "ArrowUp") {
    return;
  }
  event.preventDefault();
  const listItems = Array.from((_a = menuRef.current) === null || _a === void 0 ? void 0 : _a.querySelectorAll("li"));
  const focusableElements = listItems.map((li) => li.querySelector('button:not(:disabled),input:not(:disabled),a:not([aria-disabled="true"])')).filter((el) => el !== null);
  let focusableElement;
  if (event.key === "ArrowDown") {
    focusableElement = focusableElements[0];
  } else {
    focusableElement = focusableElements[focusableElements.length - 1];
  }
  focusableElement && focusableElement.focus();
};
var KeyboardHandler = class extends import_react8.Component {
  constructor() {
    super(...arguments);
    this.keyHandler = (event) => {
      const { isEventFromContainer } = this.props;
      if (isEventFromContainer ? !isEventFromContainer(event) : !this._isEventFromContainer(event)) {
        return;
      }
      const { isActiveElement, getFocusableElement, noVerticalArrowHandling, noHorizontalArrowHandling, noEnterHandling, noSpaceHandling, updateTabIndex, validSiblingTags, additionalKeyHandler, createNavigableElements, onlyTraverseSiblings } = this.props;
      additionalKeyHandler && additionalKeyHandler(event);
      const navigableElements = createNavigableElements();
      if (!navigableElements) {
        console.warn("No navigable elements have been passed to the KeyboardHandler. Keyboard navigation provided by this component will be ignored.");
        return;
      }
      const key = event.key;
      if (!noEnterHandling) {
        if (key === "Enter") {
          event.preventDefault();
          event.stopImmediatePropagation();
          document.activeElement.click();
        }
      }
      if (!noSpaceHandling) {
        if (key === " ") {
          event.preventDefault();
          event.stopImmediatePropagation();
          document.activeElement.click();
        }
      }
      handleArrows(event, navigableElements, isActiveElement, getFocusableElement, validSiblingTags, noVerticalArrowHandling, noHorizontalArrowHandling, updateTabIndex, onlyTraverseSiblings);
    };
    this._isEventFromContainer = (event) => {
      const { containerRef } = this.props;
      return containerRef.current && containerRef.current.contains(event.target);
    };
  }
  componentDidMount() {
    if (canUseDOM) {
      window.addEventListener("keydown", this.keyHandler);
    }
  }
  componentWillUnmount() {
    if (canUseDOM) {
      window.removeEventListener("keydown", this.keyHandler);
    }
  }
  render() {
    return null;
  }
};
KeyboardHandler.displayName = "KeyboardHandler";
KeyboardHandler.defaultProps = {
  containerRef: null,
  createNavigableElements: () => null,
  isActiveElement: (navigableElement) => document.activeElement === navigableElement,
  getFocusableElement: (navigableElement) => navigableElement,
  validSiblingTags: ["BUTTON", "A"],
  onlyTraverseSiblings: true,
  updateTabIndex: true,
  noHorizontalArrowHandling: false,
  noVerticalArrowHandling: false,
  noEnterHandling: false,
  noSpaceHandling: false
};

// node_modules/@patternfly/react-core/dist/esm/helpers/resizeObserver.js
var getResizeObserver = (containerRefElement, handleResize, useRequestAnimationFrame) => {
  let unobserve;
  if (canUseDOM) {
    const { ResizeObserver } = window;
    if (containerRefElement && ResizeObserver) {
      const resizeObserver = new ResizeObserver((entries) => {
        if (useRequestAnimationFrame) {
          window.requestAnimationFrame(() => {
            if (Array.isArray(entries) && entries.length > 0) {
              debounce(handleResize, 100);
            }
          });
        } else {
          if (Array.isArray(entries) && entries.length > 0) {
            handleResize();
          }
        }
      });
      resizeObserver.observe(containerRefElement);
      unobserve = () => resizeObserver.unobserve(containerRefElement);
    } else {
      window.addEventListener("resize", handleResize);
      unobserve = () => window.removeEventListener("resize", handleResize);
    }
  }
  return () => {
    if (unobserve) {
      unobserve();
    }
  };
};

// node_modules/@patternfly/react-core/dist/esm/helpers/useInterval.js
var import_react9 = __toESM(require_react());
function useInterval(callback, delay3) {
  const savedCallback = (0, import_react9.useRef)(() => {
  });
  (0, import_react9.useEffect)(() => {
    savedCallback.current = callback;
  }, [callback]);
  (0, import_react9.useEffect)(() => {
    function tick() {
      savedCallback.current();
    }
    if (delay3 !== null) {
      const id = setInterval(tick, delay3);
      return () => clearInterval(id);
    }
  }, [delay3]);
}

// node_modules/@patternfly/react-core/dist/esm/helpers/datetimeUtils.js
var isValidDate = (date) => Boolean(date && !isNaN(date));

// node_modules/@patternfly/react-core/dist/esm/components/Spinner/Spinner.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime());

// node_modules/@patternfly/react-styles/css/components/Spinner/spinner.mjs
import "/Users/pamparan/Desktop/Edge - AI Design support  /amplify-edge/frontend/node_modules/@patternfly/react-styles/css/components/Spinner/spinner.css";
var spinner_default = {
  "modifiers": {
    "inline": "pf-m-inline",
    "xs": "pf-m-xs",
    "sm": "pf-m-sm",
    "md": "pf-m-md",
    "lg": "pf-m-lg",
    "xl": "pf-m-xl"
  },
  "spinner": "pf-v6-c-spinner",
  "spinnerPath": "pf-v6-c-spinner__path"
};

// node_modules/@patternfly/react-tokens/dist/esm/c_spinner_diameter.js
var c_spinner_diameter = {
  "name": "--pf-v6-c-spinner--diameter",
  "value": "3.5rem",
  "var": "var(--pf-v6-c-spinner--diameter)"
};
var c_spinner_diameter_default = c_spinner_diameter;

// node_modules/@patternfly/react-core/dist/esm/components/Spinner/Spinner.js
var spinnerSize;
(function(spinnerSize2) {
  spinnerSize2["sm"] = "sm";
  spinnerSize2["md"] = "md";
  spinnerSize2["lg"] = "lg";
  spinnerSize2["xl"] = "xl";
})(spinnerSize || (spinnerSize = {}));
var Spinner = (_a) => {
  var { className = "", size = "xl", "aria-valuetext": ariaValueText = "Loading...", diameter, isInline = false, "aria-label": ariaLabel, "aria-labelledBy": ariaLabelledBy } = _a, props = __rest(_a, ["className", "size", "aria-valuetext", "diameter", "isInline", "aria-label", "aria-labelledBy"]);
  return (0, import_jsx_runtime3.jsx)("svg", Object.assign({ className: css(spinner_default.spinner, isInline ? spinner_default.modifiers.inline : spinner_default.modifiers[size], className), role: "progressbar", "aria-valuetext": ariaValueText, viewBox: "0 0 100 100" }, diameter && { style: { [c_spinner_diameter_default.name]: diameter } }, ariaLabel && { "aria-label": ariaLabel }, ariaLabelledBy && { "aria-labelledBy": ariaLabelledBy }, !ariaLabel && !ariaLabelledBy && { "aria-label": "Contents" }, props, { children: (0, import_jsx_runtime3.jsx)("circle", { className: spinner_default.spinnerPath, cx: "50", cy: "50", r: "45", fill: "none" }) }));
};
Spinner.displayName = "Spinner";

// node_modules/@patternfly/react-core/dist/esm/components/Badge/Badge.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime());

// node_modules/@patternfly/react-styles/css/components/Badge/badge.mjs
import "/Users/pamparan/Desktop/Edge - AI Design support  /amplify-edge/frontend/node_modules/@patternfly/react-styles/css/components/Badge/badge.css";
var badge_default = {
  "badge": "pf-v6-c-badge",
  "badgeToggleIcon": "pf-v6-c-badge__toggle-icon",
  "modifiers": {
    "read": "pf-m-read",
    "unread": "pf-m-unread",
    "disabled": "pf-m-disabled"
  }
};

// node_modules/@patternfly/react-core/dist/esm/components/Badge/Badge.js
var Badge = (_a) => {
  var { isRead = false, isDisabled = false, className = "", children = "", screenReaderText } = _a, props = __rest(_a, ["isRead", "isDisabled", "className", "children", "screenReaderText"]);
  return (0, import_jsx_runtime4.jsxs)("span", Object.assign({}, props, { className: css(badge_default.badge, isRead ? badge_default.modifiers.read : badge_default.modifiers.unread, isDisabled && badge_default.modifiers.disabled, className), children: [children, screenReaderText && (0, import_jsx_runtime4.jsx)("span", { className: "pf-v6-screen-reader", children: screenReaderText })] }));
};
Badge.displayName = "Badge";

// node_modules/@patternfly/react-core/dist/esm/components/Button/Button.js
var import_jsx_runtime6 = __toESM(require_jsx_runtime());
var import_react10 = __toESM(require_react());

// node_modules/@patternfly/react-styles/css/components/Button/button.mjs
import "/Users/pamparan/Desktop/Edge - AI Design support  /amplify-edge/frontend/node_modules/@patternfly/react-styles/css/components/Button/button.css";
var button_default = {
  "badge": "pf-v6-c-badge",
  "button": "pf-v6-c-button",
  "buttonCount": "pf-v6-c-button__count",
  "buttonHamburgerIcon": "pf-v6-c-button--hamburger-icon",
  "buttonHamburgerIconArrow": "pf-v6-c-button--hamburger-icon--arrow",
  "buttonHamburgerIconBottom": "pf-v6-c-button--hamburger-icon--bottom",
  "buttonHamburgerIconMiddle": "pf-v6-c-button--hamburger-icon--middle",
  "buttonHamburgerIconTop": "pf-v6-c-button--hamburger-icon--top",
  "buttonIcon": "pf-v6-c-button__icon",
  "buttonIconFavorite": "pf-v6-c-button__icon-favorite",
  "buttonIconFavorited": "pf-v6-c-button__icon-favorited",
  "buttonProgress": "pf-v6-c-button__progress",
  "buttonText": "pf-v6-c-button__text",
  "modifiers": {
    "primary": "pf-m-primary",
    "unread": "pf-m-unread",
    "secondary": "pf-m-secondary",
    "danger": "pf-m-danger",
    "tertiary": "pf-m-tertiary",
    "link": "pf-m-link",
    "inline": "pf-m-inline",
    "displayLg": "pf-m-display-lg",
    "warning": "pf-m-warning",
    "control": "pf-m-control",
    "stateful": "pf-m-stateful",
    "read": "pf-m-read",
    "attention": "pf-m-attention",
    "plain": "pf-m-plain",
    "noPadding": "pf-m-no-padding",
    "block": "pf-m-block",
    "small": "pf-m-small",
    "favorite": "pf-m-favorite",
    "favorited": "pf-m-favorited",
    "settings": "pf-m-settings",
    "hamburger": "pf-m-hamburger",
    "expand": "pf-m-expand",
    "collapse": "pf-m-collapse",
    "clicked": "pf-m-clicked",
    "disabled": "pf-m-disabled",
    "ariaDisabled": "pf-m-aria-disabled",
    "progress": "pf-m-progress",
    "inProgress": "pf-m-in-progress",
    "notify": "pf-m-notify",
    "start": "pf-m-start",
    "end": "pf-m-end"
  },
  "spinner": "pf-v6-c-spinner"
};

// node_modules/@patternfly/react-core/dist/esm/components/Button/hamburgerIcon.js
var import_jsx_runtime5 = __toESM(require_jsx_runtime());
var hamburgerIcon = (0, import_jsx_runtime5.jsxs)("svg", { viewBox: "0 0 10 10", className: css(button_default.buttonHamburgerIcon, "pf-v6-svg"), width: "1em", height: "1em", children: [(0, import_jsx_runtime5.jsx)("path", { className: css(button_default.buttonHamburgerIconTop), d: "M1,1 L9,1" }), (0, import_jsx_runtime5.jsx)("path", { className: css(button_default.buttonHamburgerIconMiddle), d: "M1,5 L9,5" }), (0, import_jsx_runtime5.jsx)("path", { className: css(button_default.buttonHamburgerIconArrow), d: "M1,5 L1,5 L1,5" }), (0, import_jsx_runtime5.jsx)("path", { className: css(button_default.buttonHamburgerIconBottom), d: "M9,9 L1,9" })] });

// node_modules/@patternfly/react-core/dist/esm/components/Button/Button.js
var ButtonVariant;
(function(ButtonVariant2) {
  ButtonVariant2["primary"] = "primary";
  ButtonVariant2["secondary"] = "secondary";
  ButtonVariant2["tertiary"] = "tertiary";
  ButtonVariant2["danger"] = "danger";
  ButtonVariant2["warning"] = "warning";
  ButtonVariant2["link"] = "link";
  ButtonVariant2["plain"] = "plain";
  ButtonVariant2["control"] = "control";
  ButtonVariant2["stateful"] = "stateful";
})(ButtonVariant || (ButtonVariant = {}));
var ButtonType;
(function(ButtonType2) {
  ButtonType2["button"] = "button";
  ButtonType2["submit"] = "submit";
  ButtonType2["reset"] = "reset";
})(ButtonType || (ButtonType = {}));
var ButtonSize;
(function(ButtonSize2) {
  ButtonSize2["default"] = "default";
  ButtonSize2["sm"] = "sm";
  ButtonSize2["lg"] = "lg";
})(ButtonSize || (ButtonSize = {}));
var ButtonState;
(function(ButtonState2) {
  ButtonState2["read"] = "read";
  ButtonState2["unread"] = "unread";
  ButtonState2["attention"] = "attention";
})(ButtonState || (ButtonState = {}));
var ButtonBase = (_a) => {
  var { children = null, className = "", component = "button", isClicked = false, isBlock = false, isDisabled = false, isAriaDisabled = false, isLoading = null, isDanger = false, isExpanded, isSettings, isHamburger, hamburgerVariant, spinnerAriaValueText, spinnerAriaLabelledBy, spinnerAriaLabel, size = ButtonSize.default, inoperableEvents = ["onClick", "onKeyPress"], isInline = false, isFavorite = false, isFavorited = false, type = ButtonType.button, variant = ButtonVariant.primary, state = ButtonState.unread, hasNoPadding = false, iconPosition = "start", "aria-label": ariaLabel = null, icon = null, role, ouiaId, ouiaSafe = true, tabIndex = null, innerRef, countOptions } = _a, props = __rest(_a, ["children", "className", "component", "isClicked", "isBlock", "isDisabled", "isAriaDisabled", "isLoading", "isDanger", "isExpanded", "isSettings", "isHamburger", "hamburgerVariant", "spinnerAriaValueText", "spinnerAriaLabelledBy", "spinnerAriaLabel", "size", "inoperableEvents", "isInline", "isFavorite", "isFavorited", "type", "variant", "state", "hasNoPadding", "iconPosition", "aria-label", "icon", "role", "ouiaId", "ouiaSafe", "tabIndex", "innerRef", "countOptions"]);
  if (isHamburger && ![true, false].includes(isExpanded)) {
    console.error("Button: when the isHamburger property is passed in, you must also pass in a boolean value to the isExpanded property. It is expected that a hamburger button controls the expansion of other content.");
  }
  if ((isSettings || isHamburger || isFavorite) && !ariaLabel && !children && !props["aria-labelledby"]) {
    console.error("Button: you must provide either visible text content or an accessible name via the aria-label or aria-labelledby properties.");
  }
  const ouiaProps = useOUIAProps(Button.displayName, ouiaId, ouiaSafe, variant);
  const Component9 = component;
  const isButtonElement = Component9 === "button";
  const isInlineSpan = isInline && Component9 === "span";
  const isIconAlignedAtEnd = iconPosition === "end" || iconPosition === "right";
  const shouldOverrideIcon = isSettings || isHamburger || isFavorite;
  const preventedEvents2 = inoperableEvents.reduce((handlers, eventToPrevent) => Object.assign(Object.assign({}, handlers), { [eventToPrevent]: (event) => {
    event.preventDefault();
  } }), {});
  const getDefaultTabIdx = () => {
    if (isDisabled) {
      return isButtonElement ? null : -1;
    } else if (isAriaDisabled) {
      return null;
    } else if (isInlineSpan) {
      return 0;
    }
  };
  const renderIcon = () => {
    let iconContent;
    if (isFavorite) {
      iconContent = (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [(0, import_jsx_runtime6.jsx)("span", { className: css("pf-v6-c-button__icon-favorite"), children: (0, import_jsx_runtime6.jsx)(outlined_star_icon_default, {}) }), (0, import_jsx_runtime6.jsx)("span", { className: css("pf-v6-c-button__icon-favorited"), children: (0, import_jsx_runtime6.jsx)(star_icon_default, {}) })] });
    }
    if (isSettings) {
      iconContent = (0, import_jsx_runtime6.jsx)(cog_icon_default, {});
    }
    if (isHamburger) {
      iconContent = hamburgerIcon;
    }
    if (icon && !shouldOverrideIcon) {
      iconContent = icon;
    }
    return iconContent && (0, import_jsx_runtime6.jsx)("span", { className: css(button_default.buttonIcon, children && button_default.modifiers[isIconAlignedAtEnd ? "end" : "start"]), children: iconContent });
  };
  const _icon = renderIcon();
  const _children = children && (0, import_jsx_runtime6.jsx)("span", { className: css("pf-v6-c-button__text"), children });
  const shouldRenderAriaDisabled = isAriaDisabled || !isButtonElement && isDisabled;
  return (0, import_jsx_runtime6.jsxs)(Component9, Object.assign({ "aria-expanded": isExpanded }, props, isAriaDisabled ? preventedEvents2 : null, shouldRenderAriaDisabled && { "aria-disabled": true }, { "aria-label": ariaLabel, className: css(button_default.button, button_default.modifiers[variant], isSettings && button_default.modifiers.settings, isHamburger && button_default.modifiers.hamburger, isHamburger && hamburgerVariant && button_default.modifiers[hamburgerVariant], isBlock && button_default.modifiers.block, isDisabled && !isButtonElement && button_default.modifiers.disabled, isAriaDisabled && button_default.modifiers.ariaDisabled, isClicked && button_default.modifiers.clicked, isInline && variant === ButtonVariant.link && button_default.modifiers.inline, isFavorite && button_default.modifiers.favorite, isFavorite && isFavorited && button_default.modifiers.favorited, isDanger && (variant === ButtonVariant.secondary || variant === ButtonVariant.link) && button_default.modifiers.danger, isLoading !== null && variant !== ButtonVariant.plain && button_default.modifiers.progress, isLoading && button_default.modifiers.inProgress, hasNoPadding && variant === ButtonVariant.plain && button_default.modifiers.noPadding, variant === ButtonVariant.stateful && button_default.modifiers[state], size === ButtonSize.sm && button_default.modifiers.small, size === ButtonSize.lg && button_default.modifiers.displayLg, className), disabled: isButtonElement ? isDisabled : null, tabIndex: tabIndex !== null ? tabIndex : getDefaultTabIdx(), type: isButtonElement || isInlineSpan ? type : null, role: isInlineSpan ? "button" : role, ref: innerRef }, ouiaProps, { children: [isLoading && (0, import_jsx_runtime6.jsx)("span", { className: css(button_default.buttonProgress), children: (0, import_jsx_runtime6.jsx)(Spinner, { size: spinnerSize.md, isInline, "aria-valuetext": spinnerAriaValueText, "aria-label": spinnerAriaLabel, "aria-labelledby": spinnerAriaLabelledBy }) }), isIconAlignedAtEnd ? (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [_children, _icon] }) : (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [_icon, _children] }), countOptions && (0, import_jsx_runtime6.jsx)("span", { className: css(button_default.buttonCount, countOptions.className), children: (0, import_jsx_runtime6.jsx)(Badge, { isRead: countOptions.isRead, isDisabled, children: countOptions.count }) })] }));
};
var Button = (0, import_react10.forwardRef)((props, ref) => (0, import_jsx_runtime6.jsx)(ButtonBase, Object.assign({ innerRef: ref }, props)));
Button.displayName = "Button";

// node_modules/@patternfly/react-core/dist/esm/components/Tooltip/Tooltip.js
var import_jsx_runtime9 = __toESM(require_jsx_runtime());
var import_react11 = __toESM(require_react());

// node_modules/@patternfly/react-styles/css/components/Tooltip/tooltip.mjs
import "/Users/pamparan/Desktop/Edge - AI Design support  /amplify-edge/frontend/node_modules/@patternfly/react-styles/css/components/Tooltip/tooltip.css";
var tooltip_default = {
  "modifiers": {
    "top": "pf-m-top",
    "topLeft": "pf-m-top-left",
    "topRight": "pf-m-top-right",
    "bottom": "pf-m-bottom",
    "bottomLeft": "pf-m-bottom-left",
    "bottomRight": "pf-m-bottom-right",
    "left": "pf-m-left",
    "leftTop": "pf-m-left-top",
    "leftBottom": "pf-m-left-bottom",
    "right": "pf-m-right",
    "rightTop": "pf-m-right-top",
    "rightBottom": "pf-m-right-bottom",
    "textAlignLeft": "pf-m-text-align-left"
  },
  "tooltip": "pf-v6-c-tooltip",
  "tooltipArrow": "pf-v6-c-tooltip__arrow",
  "tooltipContent": "pf-v6-c-tooltip__content"
};

// node_modules/@patternfly/react-core/dist/esm/components/Tooltip/TooltipContent.js
var import_jsx_runtime7 = __toESM(require_jsx_runtime());
var TooltipContent = (_a) => {
  var { className, children, isLeftAligned } = _a, props = __rest(_a, ["className", "children", "isLeftAligned"]);
  return (0, import_jsx_runtime7.jsx)("div", Object.assign({ className: css(tooltip_default.tooltipContent, isLeftAligned && tooltip_default.modifiers.textAlignLeft, className) }, props, { children }));
};
TooltipContent.displayName = "TooltipContent";

// node_modules/@patternfly/react-core/dist/esm/components/Tooltip/TooltipArrow.js
var import_jsx_runtime8 = __toESM(require_jsx_runtime());
var TooltipArrow = (_a) => {
  var { className } = _a, props = __rest(_a, ["className"]);
  return (0, import_jsx_runtime8.jsx)("div", Object.assign({ className: css(tooltip_default.tooltipArrow, className) }, props));
};
TooltipArrow.displayName = "TooltipArrow";

// node_modules/@patternfly/react-tokens/dist/esm/c_tooltip_MaxWidth.js
var c_tooltip_MaxWidth = {
  "name": "--pf-v6-c-tooltip--MaxWidth",
  "value": "18.75rem",
  "var": "var(--pf-v6-c-tooltip--MaxWidth)"
};
var c_tooltip_MaxWidth_default = c_tooltip_MaxWidth;

// node_modules/@patternfly/react-core/dist/esm/components/Tooltip/Tooltip.js
var TooltipPosition;
(function(TooltipPosition2) {
  TooltipPosition2["auto"] = "auto";
  TooltipPosition2["top"] = "top";
  TooltipPosition2["bottom"] = "bottom";
  TooltipPosition2["left"] = "left";
  TooltipPosition2["right"] = "right";
  TooltipPosition2["topStart"] = "top-start";
  TooltipPosition2["topEnd"] = "top-end";
  TooltipPosition2["bottomStart"] = "bottom-start";
  TooltipPosition2["bottomEnd"] = "bottom-end";
  TooltipPosition2["leftStart"] = "left-start";
  TooltipPosition2["leftEnd"] = "left-end";
  TooltipPosition2["rightStart"] = "right-start";
  TooltipPosition2["rightEnd"] = "right-end";
})(TooltipPosition || (TooltipPosition = {}));
var pfTooltipIdCounter = 1;
var Tooltip = (_a) => {
  var {
    content: bodyContent,
    position = "top",
    trigger = "mouseenter focus",
    isVisible = false,
    isContentLeftAligned = false,
    enableFlip = true,
    className = "",
    entryDelay = 300,
    exitDelay = 300,
    appendTo = () => document.body,
    zIndex = 9999,
    minWidth,
    maxWidth = c_tooltip_MaxWidth_default.value,
    distance = 15,
    aria = "describedby",
    // For every initial starting position, there are 3 escape positions
    flipBehavior = ["top", "right", "bottom", "left", "top", "right", "bottom"],
    id = `pf-tooltip-${pfTooltipIdCounter++}`,
    children,
    animationDuration = 300,
    triggerRef,
    "aria-live": ariaLive = triggerRef ? "polite" : "off",
    onTooltipHidden = () => {
    }
  } = _a, rest = __rest(_a, ["content", "position", "trigger", "isVisible", "isContentLeftAligned", "enableFlip", "className", "entryDelay", "exitDelay", "appendTo", "zIndex", "minWidth", "maxWidth", "distance", "aria", "flipBehavior", "id", "children", "animationDuration", "triggerRef", "aria-live", "onTooltipHidden"]);
  const hideOnClick = true;
  const triggerOnMouseenter = trigger.includes("mouseenter");
  const triggerOnFocus = trigger.includes("focus");
  const triggerOnClick = trigger.includes("click");
  const triggerManually = trigger === "manual";
  const [visible, setVisible] = (0, import_react11.useState)(false);
  const popperRef = (0, import_react11.createRef)();
  const onDocumentKeyDown = (event) => {
    if (!triggerManually) {
      if (event.key === KeyTypes.Escape && visible) {
        hide2();
      }
    }
  };
  const onTriggerEnter = (event) => {
    if (event.key === KeyTypes.Enter) {
      if (!visible) {
        show();
      } else {
        hide2();
      }
    }
  };
  (0, import_react11.useEffect)(() => {
    if (isVisible) {
      show();
    } else {
      hide2();
    }
  }, [isVisible]);
  const show = () => {
    setVisible(true);
  };
  const hide2 = () => {
    setVisible(false);
  };
  const positionModifiers = {
    top: tooltip_default.modifiers.top,
    bottom: tooltip_default.modifiers.bottom,
    left: tooltip_default.modifiers.left,
    right: tooltip_default.modifiers.right,
    "top-start": tooltip_default.modifiers.topLeft,
    "top-end": tooltip_default.modifiers.topRight,
    "bottom-start": tooltip_default.modifiers.bottomLeft,
    "bottom-end": tooltip_default.modifiers.bottomRight,
    "left-start": tooltip_default.modifiers.leftTop,
    "left-end": tooltip_default.modifiers.leftBottom,
    "right-start": tooltip_default.modifiers.rightTop,
    "right-end": tooltip_default.modifiers.rightBottom
  };
  const hasCustomMaxWidth = maxWidth !== c_tooltip_MaxWidth_default.value;
  const content = (0, import_jsx_runtime9.jsxs)("div", Object.assign({ "aria-live": ariaLive, className: css(tooltip_default.tooltip, className), role: "tooltip", id, style: {
    maxWidth: hasCustomMaxWidth ? maxWidth : null
  }, ref: popperRef }, rest, { children: [(0, import_jsx_runtime9.jsx)(TooltipArrow, {}), (0, import_jsx_runtime9.jsx)(TooltipContent, { isLeftAligned: isContentLeftAligned, children: bodyContent })] }));
  const onDocumentClick = (event, triggerElement) => {
    if (hideOnClick === true) {
      if (visible) {
        hide2();
      } else if (event.target === triggerElement) {
        show();
      }
    } else if (hideOnClick === "toggle" && event.target === triggerElement) {
      if (visible) {
        hide2();
      } else {
        show();
      }
    } else if (hideOnClick === false && !visible && event.target === triggerElement) {
      show();
    }
  };
  const addAriaToTrigger = () => {
    if (aria === "describedby" && children && children.props && !children.props["aria-describedby"]) {
      return (0, import_react11.cloneElement)(children, { "aria-describedby": id });
    } else if (aria === "labelledby" && children.props && !children.props["aria-labelledby"]) {
      return (0, import_react11.cloneElement)(children, { "aria-labelledby": id });
    }
    return children;
  };
  return (0, import_jsx_runtime9.jsx)(Popper, { trigger: aria !== "none" && visible ? addAriaToTrigger() : children, triggerRef, popper: content, popperRef, minWidth: minWidth !== void 0 ? minWidth : "revert", appendTo, isVisible: visible, positionModifiers, distance, placement: position, onMouseEnter: triggerOnMouseenter && show, onMouseLeave: triggerOnMouseenter && hide2, onPopperMouseEnter: triggerOnMouseenter && show, onPopperMouseLeave: triggerOnMouseenter && hide2, onFocus: triggerOnFocus && show, onBlur: triggerOnFocus && hide2, onDocumentClick: triggerOnClick && onDocumentClick, onDocumentKeyDown: triggerManually ? null : onDocumentKeyDown, onTriggerEnter: triggerManually ? null : onTriggerEnter, enableFlip, zIndex, flipBehavior, animationDuration, entryDelay, exitDelay, onHidden: onTooltipHidden });
};
Tooltip.displayName = "Tooltip";

// node_modules/@patternfly/react-core/dist/esm/components/ActionList/ActionList.js
var import_jsx_runtime10 = __toESM(require_jsx_runtime());

// node_modules/@patternfly/react-styles/css/components/ActionList/action-list.mjs
import "/Users/pamparan/Desktop/Edge - AI Design support  /amplify-edge/frontend/node_modules/@patternfly/react-styles/css/components/ActionList/action-list.css";
var action_list_default = {
  "actionList": "pf-v6-c-action-list",
  "actionListGroup": "pf-v6-c-action-list__group",
  "modifiers": {
    "icons": "pf-m-icons"
  }
};

// node_modules/@patternfly/react-core/dist/esm/components/ActionList/ActionList.js
var ActionList = (_a) => {
  var { children, isIconList, className } = _a, props = __rest(_a, ["children", "isIconList", "className"]);
  return (0, import_jsx_runtime10.jsx)("div", Object.assign({ className: css(action_list_default.actionList, isIconList && action_list_default.modifiers.icons, className) }, props, { children }));
};
ActionList.displayName = "ActionList";

// node_modules/@patternfly/react-core/dist/esm/components/ActionList/ActionListGroup.js
var import_jsx_runtime11 = __toESM(require_jsx_runtime());
var ActionListGroup = (_a) => {
  var { children, className, isIconGroup } = _a, props = __rest(_a, ["children", "className", "isIconGroup"]);
  return (0, import_jsx_runtime11.jsx)("div", Object.assign({ className: css(action_list_default.actionListGroup, isIconGroup && action_list_default.modifiers.icons, className) }, props, { children }));
};
ActionListGroup.displayName = "ActionListGroup";

// node_modules/@patternfly/react-core/dist/esm/components/ActionList/ActionListItem.js
var import_jsx_runtime12 = __toESM(require_jsx_runtime());
var ActionListItem = (_a) => {
  var { children, className } = _a, props = __rest(_a, ["children", "className"]);
  return (0, import_jsx_runtime12.jsx)("div", Object.assign({ className: css(`${action_list_default.actionList}__item`, className) }, props, { children }));
};
ActionListItem.displayName = "ActionListItem";

// node_modules/@patternfly/react-core/dist/esm/components/TextInput/TextInput.js
var import_jsx_runtime14 = __toESM(require_jsx_runtime());
var import_react12 = __toESM(require_react());

// node_modules/@patternfly/react-styles/css/components/FormControl/form-control.mjs
import "/Users/pamparan/Desktop/Edge - AI Design support  /amplify-edge/frontend/node_modules/@patternfly/react-styles/css/components/FormControl/form-control.css";
var form_control_default = {
  "formControl": "pf-v6-c-form-control",
  "formControlIcon": "pf-v6-c-form-control__icon",
  "formControlToggleIcon": "pf-v6-c-form-control__toggle-icon",
  "formControlUtilities": "pf-v6-c-form-control__utilities",
  "modifiers": {
    "textarea": "pf-m-textarea",
    "success": "pf-m-success",
    "warning": "pf-m-warning",
    "error": "pf-m-error",
    "readonly": "pf-m-readonly",
    "plain": "pf-m-plain",
    "expanded": "pf-m-expanded",
    "disabled": "pf-m-disabled",
    "status": "pf-m-status",
    "icon": "pf-m-icon",
    "placeholder": "pf-m-placeholder",
    "resizeVertical": "pf-m-resize-vertical",
    "resizeHorizontal": "pf-m-resize-horizontal",
    "resizeBoth": "pf-m-resize-both"
  }
};

// node_modules/@patternfly/react-core/dist/esm/components/FormControl/FormControlIcon.js
var import_jsx_runtime13 = __toESM(require_jsx_runtime());
var statusIcons2 = {
  success: check_circle_icon_default,
  error: exclamation_circle_icon_default,
  warning: exclamation_triangle_icon_default
};
var FormControlIcon = (_a) => {
  var { status, customIcon, className } = _a, props = __rest(_a, ["status", "customIcon", "className"]);
  const StatusIcon = status && statusIcons2[status];
  return (0, import_jsx_runtime13.jsx)("span", Object.assign({ className: css(form_control_default.formControlIcon, status && form_control_default.modifiers.status, className) }, props, { children: customIcon || (0, import_jsx_runtime13.jsx)(StatusIcon, {}) }));
};

// node_modules/@patternfly/react-core/dist/esm/components/TextInput/TextInput.js
var TextInputTypes;
(function(TextInputTypes2) {
  TextInputTypes2["text"] = "text";
  TextInputTypes2["date"] = "date";
  TextInputTypes2["datetimeLocal"] = "datetime-local";
  TextInputTypes2["email"] = "email";
  TextInputTypes2["month"] = "month";
  TextInputTypes2["number"] = "number";
  TextInputTypes2["password"] = "password";
  TextInputTypes2["search"] = "search";
  TextInputTypes2["tel"] = "tel";
  TextInputTypes2["time"] = "time";
  TextInputTypes2["url"] = "url";
})(TextInputTypes || (TextInputTypes = {}));
var TextInputReadOnlyVariant;
(function(TextInputReadOnlyVariant2) {
  TextInputReadOnlyVariant2["default"] = "default";
  TextInputReadOnlyVariant2["plain"] = "plain";
})(TextInputReadOnlyVariant || (TextInputReadOnlyVariant = {}));
var TextInputBase = class _TextInputBase extends import_react12.Component {
  constructor(props) {
    super(props);
    this.inputRef = (0, import_react12.createRef)();
    this.observer = () => {
    };
    this.handleChange = (event) => {
      if (this.props.onChange) {
        this.props.onChange(event, event.currentTarget.value);
      }
    };
    this.handleResize = () => {
      const inputRef = this.props.innerRef || this.inputRef;
      if (inputRef && inputRef.current) {
        trimLeft(inputRef.current, String(this.props.value));
      }
    };
    this.restoreText = () => {
      const inputRef = this.props.innerRef || this.inputRef;
      inputRef.current.value = String(this.props.value);
      inputRef.current.scrollLeft = inputRef.current.scrollWidth;
    };
    this.onFocus = (event) => {
      const { isLeftTruncated, isStartTruncated, onFocus } = this.props;
      if (isLeftTruncated || isStartTruncated) {
        this.restoreText();
      }
      onFocus && onFocus(event);
    };
    this.onBlur = (event) => {
      const { isLeftTruncated, isStartTruncated, onBlur } = this.props;
      if (isLeftTruncated || isStartTruncated) {
        this.handleResize();
      }
      onBlur && onBlur(event);
    };
    this.sanitizeInputValue = (value) => typeof value === "string" ? value.replace(/\n/g, " ") : value;
    if (!props.id && !props["aria-label"] && !props["aria-labelledby"]) {
      console.error("Text input:", "Text input requires either an id or aria-label to be specified");
    }
    this.state = {
      ouiaStateId: getDefaultOUIAId(_TextInputBase.displayName)
    };
  }
  componentDidMount() {
    if (this.props.isLeftTruncated || this.props.isStartTruncated) {
      const inputRef = this.props.innerRef || this.inputRef;
      this.observer = getResizeObserver(inputRef.current, this.handleResize, true);
      this.handleResize();
    }
  }
  componentWillUnmount() {
    if (this.props.isLeftTruncated || this.props.isStartTruncated) {
      this.observer();
    }
  }
  render() {
    const _a = this.props, {
      innerRef,
      className,
      type,
      value,
      placeholder,
      validated,
      /* eslint-disable @typescript-eslint/no-unused-vars */
      onChange,
      onFocus,
      onBlur,
      isLeftTruncated,
      isStartTruncated,
      isExpanded,
      expandedProps,
      readOnly,
      readOnlyVariant,
      isRequired,
      isDisabled,
      customIcon,
      ouiaId,
      ouiaSafe
    } = _a, props = __rest(_a, ["innerRef", "className", "type", "value", "placeholder", "validated", "onChange", "onFocus", "onBlur", "isLeftTruncated", "isStartTruncated", "isExpanded", "expandedProps", "readOnly", "readOnlyVariant", "isRequired", "isDisabled", "customIcon", "ouiaId", "ouiaSafe"]);
    const hasStatusIcon = ["success", "error", "warning"].includes(validated);
    const ariaExpandedProps = expandedProps ? { "aria-expanded": expandedProps === null || expandedProps === void 0 ? void 0 : expandedProps.isExpanded, "aria-controls": expandedProps === null || expandedProps === void 0 ? void 0 : expandedProps.ariaControls, role: "combobox" } : {};
    return (0, import_jsx_runtime14.jsxs)("span", { className: css(form_control_default.formControl, readOnlyVariant && form_control_default.modifiers.readonly, readOnlyVariant === "plain" && form_control_default.modifiers.plain, isDisabled && form_control_default.modifiers.disabled, (isExpanded || (expandedProps === null || expandedProps === void 0 ? void 0 : expandedProps.isExpanded)) && form_control_default.modifiers.expanded, customIcon && form_control_default.modifiers.icon, hasStatusIcon && form_control_default.modifiers[validated], className), children: [(0, import_jsx_runtime14.jsx)("input", Object.assign({}, props, { onFocus: this.onFocus, onBlur: this.onBlur, onChange: this.handleChange, type, value: this.sanitizeInputValue(value), "aria-invalid": props["aria-invalid"] ? props["aria-invalid"] : validated === ValidatedOptions.error }, ariaExpandedProps, { required: isRequired, disabled: isDisabled, readOnly: !!readOnlyVariant || readOnly, ref: innerRef || this.inputRef, placeholder }, getOUIAProps(TextInput.displayName, ouiaId !== void 0 ? ouiaId : this.state.ouiaStateId, ouiaSafe))), (customIcon || hasStatusIcon) && (0, import_jsx_runtime14.jsxs)("span", { className: css(form_control_default.formControlUtilities), children: [customIcon && (0, import_jsx_runtime14.jsx)(FormControlIcon, { customIcon }), hasStatusIcon && (0, import_jsx_runtime14.jsx)(FormControlIcon, { status: validated })] })] });
  }
};
TextInputBase.displayName = "TextInputBase";
TextInputBase.defaultProps = {
  "aria-label": null,
  isRequired: false,
  validated: "default",
  isDisabled: false,
  isExpanded: false,
  type: TextInputTypes.text,
  isLeftTruncated: false,
  isStartTruncated: false,
  onChange: () => void 0,
  ouiaSafe: true
};
var TextInput = (0, import_react12.forwardRef)((props, ref) => (0, import_jsx_runtime14.jsx)(TextInputBase, Object.assign({}, props, { innerRef: ref })));
TextInput.displayName = "TextInput";

// node_modules/@patternfly/react-core/dist/esm/components/Menu/Menu.js
var import_jsx_runtime15 = __toESM(require_jsx_runtime());
var import_react14 = __toESM(require_react());

// node_modules/@patternfly/react-styles/css/components/Menu/menu.mjs
import "/Users/pamparan/Desktop/Edge - AI Design support  /amplify-edge/frontend/node_modules/@patternfly/react-styles/css/components/Menu/menu.css";
var menu_default = {
  "button": "pf-v6-c-button",
  "check": "pf-v6-c-check",
  "dirRtl": "pf-v6-m-dir-rtl",
  "divider": "pf-v6-c-divider",
  "menu": "pf-v6-c-menu",
  "menuBreadcrumb": "pf-v6-c-menu__breadcrumb",
  "menuContent": "pf-v6-c-menu__content",
  "menuFooter": "pf-v6-c-menu__footer",
  "menuGroup": "pf-v6-c-menu__group",
  "menuGroupTitle": "pf-v6-c-menu__group-title",
  "menuHeader": "pf-v6-c-menu__header",
  "menuItem": "pf-v6-c-menu__item",
  "menuItemAction": "pf-v6-c-menu__item-action",
  "menuItemActionIcon": "pf-v6-c-menu__item-action-icon",
  "menuItemCheck": "pf-v6-c-menu__item-check",
  "menuItemDescription": "pf-v6-c-menu__item-description",
  "menuItemExternalIcon": "pf-v6-c-menu__item-external-icon",
  "menuItemIcon": "pf-v6-c-menu__item-icon",
  "menuItemMain": "pf-v6-c-menu__item-main",
  "menuItemSelectIcon": "pf-v6-c-menu__item-select-icon",
  "menuItemText": "pf-v6-c-menu__item-text",
  "menuItemToggleIcon": "pf-v6-c-menu__item-toggle-icon",
  "menuList": "pf-v6-c-menu__list",
  "menuListItem": "pf-v6-c-menu__list-item",
  "menuSearch": "pf-v6-c-menu__search",
  "menuToggle": "pf-v6-c-menu-toggle",
  "modifiers": {
    "hidden": "pf-m-hidden",
    "hiddenOnSm": "pf-m-hidden-on-sm",
    "visibleOnSm": "pf-m-visible-on-sm",
    "hiddenOnMd": "pf-m-hidden-on-md",
    "visibleOnMd": "pf-m-visible-on-md",
    "hiddenOnLg": "pf-m-hidden-on-lg",
    "visibleOnLg": "pf-m-visible-on-lg",
    "hiddenOnXl": "pf-m-hidden-on-xl",
    "visibleOnXl": "pf-m-visible-on-xl",
    "hiddenOn_2xl": "pf-m-hidden-on-2xl",
    "visibleOn_2xl": "pf-m-visible-on-2xl",
    "disabled": "pf-m-disabled",
    "ariaDisabled": "pf-m-aria-disabled",
    "flyout": "pf-m-flyout",
    "top": "pf-m-top",
    "left": "pf-m-left",
    "drilldown": "pf-m-drilldown",
    "drilledIn": "pf-m-drilled-in",
    "currentPath": "pf-m-current-path",
    "static": "pf-m-static",
    "plain": "pf-m-plain",
    "scrollable": "pf-m-scrollable",
    "load": "pf-m-load",
    "loading": "pf-m-loading",
    "danger": "pf-m-danger",
    "focus": "pf-m-focus",
    "selected": "pf-m-selected",
    "favorited": "pf-m-favorited"
  }
};

// node_modules/@patternfly/react-styles/css/components/Breadcrumb/breadcrumb.mjs
import "/Users/pamparan/Desktop/Edge - AI Design support  /amplify-edge/frontend/node_modules/@patternfly/react-styles/css/components/Breadcrumb/breadcrumb.css";
var breadcrumb_default = {
  "breadcrumb": "pf-v6-c-breadcrumb",
  "breadcrumbDropdown": "pf-v6-c-breadcrumb__dropdown",
  "breadcrumbHeading": "pf-v6-c-breadcrumb__heading",
  "breadcrumbItem": "pf-v6-c-breadcrumb__item",
  "breadcrumbItemDivider": "pf-v6-c-breadcrumb__item-divider",
  "breadcrumbLink": "pf-v6-c-breadcrumb__link",
  "breadcrumbList": "pf-v6-c-breadcrumb__list",
  "dirRtl": "pf-v6-m-dir-rtl",
  "modifiers": {
    "current": "pf-m-current"
  }
};

// node_modules/@patternfly/react-core/dist/esm/components/Menu/MenuContext.js
var import_react13 = __toESM(require_react());
var MenuContext = (0, import_react13.createContext)({
  menuId: null,
  parentMenu: null,
  onActionClick: () => null,
  onSelect: () => null,
  activeItemId: null,
  selected: null,
  drilledInMenus: [],
  drilldownItemPath: [],
  onDrillIn: null,
  onDrillOut: null,
  onGetMenuHeight: () => null,
  flyoutRef: null,
  setFlyoutRef: () => null,
  disableHover: false,
  role: "menu"
});
var MenuItemContext = (0, import_react13.createContext)({
  itemId: null,
  isDisabled: false
});

// node_modules/@patternfly/react-core/dist/esm/components/Menu/Menu.js
var MenuBase = class extends import_react14.Component {
  constructor(props) {
    super(props);
    this.menuRef = (0, import_react14.createRef)();
    this.activeMenu = null;
    this.state = {
      ouiaStateId: getDefaultOUIAId(Menu.displayName),
      transitionMoveTarget: null,
      flyoutRef: null,
      disableHover: false,
      currentDrilldownMenuId: this.props.id
    };
    this.handleDrilldownTransition = (event) => {
      const current = this.menuRef.current;
      if (!current || current !== event.target.closest(`.${menu_default.menu}`) && !Array.from(current.getElementsByClassName(menu_default.menu)).includes(event.target.closest(`.${menu_default.menu}`))) {
        return;
      }
      if (this.state.transitionMoveTarget) {
        this.state.transitionMoveTarget.focus();
        this.setState({ transitionMoveTarget: null });
      } else {
        const nextMenu = current.querySelector("#" + this.props.activeMenu) || current || null;
        const nextMenuLists = nextMenu.getElementsByTagName("UL");
        if (nextMenuLists.length === 0) {
          return;
        }
        const nextMenuChildren = Array.from(nextMenuLists[0].children);
        if (!this.state.currentDrilldownMenuId || nextMenu.id !== this.state.currentDrilldownMenuId) {
          this.setState({ currentDrilldownMenuId: nextMenu.id });
        } else {
          return;
        }
        const nextTarget = nextMenuChildren.filter((el) => !(el.classList.contains("pf-m-disabled") || el.classList.contains(menu_default.divider)))[0].firstChild;
        nextTarget.focus();
        nextTarget.tabIndex = 0;
      }
    };
    this.handleExtraKeys = (event) => {
      const isDrilldown = this.props.containsDrilldown;
      const activeElement = document.activeElement;
      if (event.target.closest(`.${menu_default.menu}`) !== this.activeMenu && !event.target.classList.contains(breadcrumb_default.breadcrumbLink)) {
        this.activeMenu = event.target.closest(`.${menu_default.menu}`);
        this.setState({ disableHover: true });
      }
      if (event.target.tagName === "INPUT") {
        return;
      }
      const parentMenu = this.activeMenu;
      const key = event.key;
      const isFromBreadcrumb = activeElement.classList.contains(breadcrumb_default.breadcrumbLink);
      if (key === " " || key === "Enter") {
        event.preventDefault();
        if (isDrilldown && !isFromBreadcrumb) {
          const isDrillingOut = activeElement.closest("li").classList.contains("pf-m-current-path");
          if (isDrillingOut && parentMenu.parentElement.tagName === "LI") {
            activeElement.tabIndex = -1;
            parentMenu.parentElement.firstChild.tabIndex = 0;
            this.setState({ transitionMoveTarget: parentMenu.parentElement.firstChild });
          } else {
            if (activeElement.nextElementSibling && activeElement.nextElementSibling.classList.contains(menu_default.menu)) {
              const childItems = Array.from(activeElement.nextElementSibling.getElementsByTagName("UL")[0].children).filter((el) => !(el.classList.contains("pf-m-disabled") || el.classList.contains(menu_default.divider)));
              activeElement.tabIndex = -1;
              childItems[0].firstChild.tabIndex = 0;
              this.setState({ transitionMoveTarget: childItems[0].firstChild });
            }
          }
        }
        document.activeElement.click();
      }
    };
    this.createNavigableElements = () => {
      const isDrilldown = this.props.containsDrilldown;
      if (isDrilldown) {
        return this.activeMenu ? Array.from(this.activeMenu.getElementsByTagName("UL")[0].children).filter((el) => !(el.classList.contains("pf-m-disabled") || el.classList.contains(menu_default.divider))) : [];
      } else {
        return this.menuRef.current ? Array.from(this.menuRef.current.getElementsByTagName("LI")).filter((el) => !(el.classList.contains("pf-m-disabled") || el.classList.contains(menu_default.divider))) : [];
      }
    };
    if (props.innerRef) {
      this.menuRef = props.innerRef;
    }
  }
  allowTabFirstItem() {
    const current = this.menuRef.current;
    if (current) {
      const first = current.querySelector("ul button:not(:disabled), ul a:not(:disabled)");
      if (first) {
        first.tabIndex = 0;
      }
    }
  }
  componentDidMount() {
    if (this.context) {
      this.setState({ disableHover: this.context.disableHover });
    }
    if (canUseDOM && this.props.containsDrilldown && this.props.isRootMenu) {
      window.addEventListener("transitionend", this.handleDrilldownTransition);
    }
    this.allowTabFirstItem();
  }
  componentWillUnmount() {
    if (canUseDOM && this.props.containsDrilldown && this.props.isRootMenu) {
      window.removeEventListener("transitionend", this.handleDrilldownTransition);
    }
  }
  componentDidUpdate(prevProps) {
    if (prevProps.children !== this.props.children) {
      this.allowTabFirstItem();
    }
  }
  render() {
    const _a = this.props, {
      id,
      children,
      className,
      onSelect,
      selected = null,
      onActionClick,
      ouiaId,
      ouiaSafe,
      containsFlyout,
      containsDrilldown,
      isMenuDrilledIn,
      isPlain,
      isScrollable,
      drilldownItemPath,
      drilledInMenus,
      onDrillIn,
      onDrillOut,
      onGetMenuHeight,
      parentMenu = null,
      activeItemId = null,
      /* eslint-disable @typescript-eslint/no-unused-vars */
      innerRef,
      isRootMenu,
      activeMenu,
      role,
      isNavFlyout
    } = _a, props = __rest(_a, ["id", "children", "className", "onSelect", "selected", "onActionClick", "ouiaId", "ouiaSafe", "containsFlyout", "containsDrilldown", "isMenuDrilledIn", "isPlain", "isScrollable", "drilldownItemPath", "drilledInMenus", "onDrillIn", "onDrillOut", "onGetMenuHeight", "parentMenu", "activeItemId", "innerRef", "isRootMenu", "activeMenu", "role", "isNavFlyout"]);
    const _isMenuDrilledIn = isMenuDrilledIn || drilledInMenus && drilledInMenus.includes(id) || false;
    return (0, import_jsx_runtime15.jsxs)(MenuContext.Provider, { value: {
      menuId: id,
      parentMenu: parentMenu || id,
      onSelect,
      onActionClick,
      activeItemId,
      selected,
      drilledInMenus,
      drilldownItemPath,
      onDrillIn,
      onDrillOut,
      onGetMenuHeight,
      flyoutRef: this.state.flyoutRef,
      setFlyoutRef: (flyoutRef) => this.setState({ flyoutRef }),
      disableHover: this.state.disableHover,
      role
    }, children: [isRootMenu && (0, import_jsx_runtime15.jsx)(KeyboardHandler, { containerRef: this.menuRef || null, additionalKeyHandler: this.handleExtraKeys, createNavigableElements: this.createNavigableElements, isActiveElement: (element) => document.activeElement.closest("li") === element || // if element is a basic MenuItem
    document.activeElement.parentElement === element || document.activeElement.closest(`.${menu_default.menuSearch}`) === element || // if element is a MenuSearch
    document.activeElement.closest("ol") && document.activeElement.closest("ol").firstChild === element, getFocusableElement: (navigableElement) => {
      var _a2, _b;
      return (navigableElement === null || navigableElement === void 0 ? void 0 : navigableElement.tagName) === "DIV" && navigableElement.querySelector("input") || // for MenuSearchInput
      ((_a2 = navigableElement.firstChild) === null || _a2 === void 0 ? void 0 : _a2.tagName) === "LABEL" && navigableElement.querySelector("input") || // for MenuItem checkboxes
      ((_b = navigableElement.firstChild) === null || _b === void 0 ? void 0 : _b.tagName) === "DIV" && navigableElement.querySelector("a, button, input") || // For aria-disabled element that is rendered inside a div with "display: contents" styling
      navigableElement.firstChild;
    }, noHorizontalArrowHandling: document.activeElement && (document.activeElement.classList.contains(breadcrumb_default.breadcrumbLink) || document.activeElement.tagName === "INPUT"), noEnterHandling: true, noSpaceHandling: true }), (0, import_jsx_runtime15.jsx)("div", Object.assign({ id, className: css(menu_default.menu, isPlain && menu_default.modifiers.plain, isScrollable && menu_default.modifiers.scrollable, containsFlyout && menu_default.modifiers.flyout, isNavFlyout && "pf-m-nav", containsDrilldown && menu_default.modifiers.drilldown, _isMenuDrilledIn && menu_default.modifiers.drilledIn, className), ref: this.menuRef }, getOUIAProps(Menu.displayName, ouiaId !== void 0 ? ouiaId : this.state.ouiaStateId, ouiaSafe), props, { children }))] });
  }
};
MenuBase.displayName = "Menu";
MenuBase.contextType = MenuContext;
MenuBase.defaultProps = {
  ouiaSafe: true,
  isRootMenu: true,
  isPlain: false,
  isScrollable: false,
  role: "menu"
};
var Menu = (0, import_react14.forwardRef)((props, ref) => (0, import_jsx_runtime15.jsx)(MenuBase, Object.assign({}, props, { innerRef: ref })));
Menu.displayName = "Menu";

// node_modules/@patternfly/react-core/dist/esm/components/Menu/MenuContent.js
var import_jsx_runtime16 = __toESM(require_jsx_runtime());
var import_react15 = __toESM(require_react());

// node_modules/@patternfly/react-tokens/dist/esm/c_menu__content_Height.js
var c_menu__content_Height = {
  "name": "--pf-v6-c-menu__content--Height",
  "value": "auto",
  "var": "var(--pf-v6-c-menu__content--Height)"
};
var c_menu_content_Height_default = c_menu__content_Height;

// node_modules/@patternfly/react-tokens/dist/esm/c_menu__content_MaxHeight.js
var c_menu__content_MaxHeight = {
  "name": "--pf-v6-c-menu__content--MaxHeight",
  "value": "18.75rem",
  "var": "var(--pf-v6-c-menu__content--MaxHeight)"
};
var c_menu_content_MaxHeight_default = c_menu__content_MaxHeight;

// node_modules/@patternfly/react-core/dist/esm/components/Menu/MenuContent.js
var MenuContent = (0, import_react15.forwardRef)((props, ref) => {
  const { getHeight, children, menuHeight, maxMenuHeight } = props, rest = __rest(props, ["getHeight", "children", "menuHeight", "maxMenuHeight"]);
  const menuContentRef = (0, import_react15.createRef)();
  const refCallback = (el, menuId, onGetMenuHeight) => {
    if (el) {
      let clientHeight = el.clientHeight;
      let rootMenuList = null;
      let parentEl = el.closest(`.${menu_default.menuList}`);
      while (parentEl !== null && parentEl.nodeType === 1) {
        if (parentEl.classList.contains(menu_default.menuList)) {
          rootMenuList = parentEl;
        }
        parentEl = parentEl.parentElement;
      }
      if (rootMenuList) {
        const rootMenuListStyles = getComputedStyle(rootMenuList);
        const rootMenuListPaddingOffset = parseFloat(rootMenuListStyles.getPropertyValue("padding-top").replace(/px/g, "")) + parseFloat(rootMenuListStyles.getPropertyValue("padding-bottom").replace(/px/g, "")) + parseFloat(getComputedStyle(rootMenuList.parentElement).getPropertyValue("border-bottom-width").replace(/px/g, ""));
        clientHeight = clientHeight + rootMenuListPaddingOffset;
      }
      onGetMenuHeight && onGetMenuHeight(menuId, clientHeight);
      getHeight && getHeight(clientHeight.toString());
    }
    return ref || menuContentRef;
  };
  return (0, import_jsx_runtime16.jsx)(MenuContext.Consumer, { children: ({ menuId, onGetMenuHeight }) => (0, import_jsx_runtime16.jsx)("div", Object.assign({}, rest, { className: css(menu_default.menuContent, props.className), ref: (el) => {
    refCallback(el, menuId, onGetMenuHeight);
  }, style: Object.assign(Object.assign({}, menuHeight && { [c_menu_content_Height_default.name]: menuHeight }), maxMenuHeight && { [c_menu_content_MaxHeight_default.name]: maxMenuHeight }), children })) });
});
MenuContent.displayName = "MenuContent";

// node_modules/@patternfly/react-core/dist/esm/components/Menu/MenuFooter.js
var import_jsx_runtime17 = __toESM(require_jsx_runtime());
var MenuFooter = (_a) => {
  var { children, className = "" } = _a, props = __rest(_a, ["children", "className"]);
  return (0, import_jsx_runtime17.jsx)("div", Object.assign({}, props, { className: css(menu_default.menuFooter, className), children }));
};
MenuFooter.displayName = "MenuFooter";

// node_modules/@patternfly/react-core/dist/esm/components/Menu/MenuSearch.js
var import_jsx_runtime18 = __toESM(require_jsx_runtime());
var import_react16 = __toESM(require_react());
var MenuSearch = (0, import_react16.forwardRef)((props, ref) => (0, import_jsx_runtime18.jsx)("div", Object.assign({}, props, { className: css(menu_default.menuSearch, props.className), ref })));
MenuSearch.displayName = "MenuSearch";

// node_modules/@patternfly/react-core/dist/esm/components/Menu/MenuSearchInput.js
var import_jsx_runtime19 = __toESM(require_jsx_runtime());
var import_react17 = __toESM(require_react());
var MenuSearchInput = (0, import_react17.forwardRef)((props, ref) => (
  // Update to use the styles object when core adds the class
  (0, import_jsx_runtime19.jsx)("div", Object.assign({}, props, { className: css(`${menu_default.menuSearch}-input`, props.className), ref }))
));
MenuSearchInput.displayName = "MenuSearchInput";

// node_modules/@patternfly/react-core/dist/esm/components/Menu/MenuGroup.js
var import_jsx_runtime20 = __toESM(require_jsx_runtime());
var import_react18 = __toESM(require_react());
var MenuGroupBase = (_a) => {
  var { children, className = "", label = "", titleId, innerRef, labelHeadingLevel: HeadingLevel = "h1" } = _a, props = __rest(_a, ["children", "className", "label", "titleId", "innerRef", "labelHeadingLevel"]);
  const Wrapper = typeof label === "function" ? label : HeadingLevel;
  return (0, import_jsx_runtime20.jsx)("section", Object.assign({}, props, { className: css(menu_default.menuGroup, className), ref: innerRef, children: (0, import_jsx_runtime20.jsxs)(import_jsx_runtime20.Fragment, { children: [["function", "string"].includes(typeof label) ? (0, import_jsx_runtime20.jsx)(Wrapper, { className: css(menu_default.menuGroupTitle), id: titleId, children: label }) : label, children] }) }));
};
var MenuGroup = (0, import_react18.forwardRef)((props, ref) => (0, import_jsx_runtime20.jsx)(MenuGroupBase, Object.assign({}, props, { innerRef: ref })));
MenuGroup.displayName = "MenuGroup";

// node_modules/@patternfly/react-core/dist/esm/components/Checkbox/Checkbox.js
var import_jsx_runtime21 = __toESM(require_jsx_runtime());
var import_react19 = __toESM(require_react());

// node_modules/@patternfly/react-styles/css/components/Check/check.mjs
import "/Users/pamparan/Desktop/Edge - AI Design support  /amplify-edge/frontend/node_modules/@patternfly/react-styles/css/components/Check/check.css";
var check_default = {
  "check": "pf-v6-c-check",
  "checkBody": "pf-v6-c-check__body",
  "checkDescription": "pf-v6-c-check__description",
  "checkInput": "pf-v6-c-check__input",
  "checkLabel": "pf-v6-c-check__label",
  "checkLabelRequired": "pf-v6-c-check__label-required",
  "modifiers": {
    "standalone": "pf-m-standalone",
    "disabled": "pf-m-disabled"
  }
};

// node_modules/@patternfly/react-core/dist/esm/components/Checkbox/Checkbox.js
var defaultOnChange = () => {
};
var Checkbox = class _Checkbox extends import_react19.Component {
  constructor(props) {
    super(props);
    this.handleChange = (event) => {
      this.props.onChange(event, event.currentTarget.checked);
    };
    this.state = {
      ouiaStateId: getDefaultOUIAId(_Checkbox.displayName)
    };
  }
  render() {
    const _a = this.props, { "aria-label": ariaLabel, className, inputClassName, onChange, isLabelWrapped, labelPosition = "end", isValid, isDisabled, isRequired, isChecked, label, checked, defaultChecked, description, body, ouiaId, ouiaSafe, component } = _a, props = __rest(_a, ["aria-label", "className", "inputClassName", "onChange", "isLabelWrapped", "labelPosition", "isValid", "isDisabled", "isRequired", "isChecked", "label", "checked", "defaultChecked", "description", "body", "ouiaId", "ouiaSafe", "component"]);
    if (!props.id) {
      console.error("Checkbox:", "id is required to make input accessible");
    }
    const checkedProps = {};
    if ([true, false].includes(checked) || isChecked === true) {
      checkedProps.checked = checked || isChecked;
    }
    if (onChange !== defaultOnChange) {
      checkedProps.checked = isChecked;
    }
    if ([false, true].includes(defaultChecked)) {
      checkedProps.defaultChecked = defaultChecked;
    }
    const inputRendered = (0, import_jsx_runtime21.jsx)("input", Object.assign({}, props, { className: css(check_default.checkInput, inputClassName), type: "checkbox", onChange: this.handleChange, "aria-invalid": !isValid, "aria-label": ariaLabel, disabled: isDisabled, required: isRequired, ref: (elem) => {
      elem && (elem.indeterminate = isChecked === null);
    } }, checkedProps, getOUIAProps(_Checkbox.displayName, ouiaId !== void 0 ? ouiaId : this.state.ouiaStateId, ouiaSafe)));
    const wrapWithLabel = isLabelWrapped && !component || component === "label";
    const Label = wrapWithLabel ? "span" : "label";
    const labelRendered = label ? (0, import_jsx_runtime21.jsxs)(Label, { className: css(check_default.checkLabel, isDisabled && check_default.modifiers.disabled), htmlFor: !wrapWithLabel ? props.id : void 0, children: [label, isRequired && (0, import_jsx_runtime21.jsx)("span", { className: css(check_default.checkLabelRequired), "aria-hidden": "true", children: ASTERISK })] }) : null;
    const Component9 = component !== null && component !== void 0 ? component : wrapWithLabel ? "label" : "div";
    checkedProps.checked = checkedProps.checked === null ? false : checkedProps.checked;
    return (0, import_jsx_runtime21.jsxs)(Component9, { className: css(check_default.check, !label && check_default.modifiers.standalone, className), htmlFor: wrapWithLabel ? props.id : void 0, children: [labelPosition === "start" ? (0, import_jsx_runtime21.jsxs)(import_jsx_runtime21.Fragment, { children: [labelRendered, inputRendered] }) : (0, import_jsx_runtime21.jsxs)(import_jsx_runtime21.Fragment, { children: [inputRendered, labelRendered] }), description && (0, import_jsx_runtime21.jsx)("span", { className: css(check_default.checkDescription), children: description }), body && (0, import_jsx_runtime21.jsx)("span", { className: css(check_default.checkBody), children: body })] });
  }
};
Checkbox.displayName = "Checkbox";
Checkbox.defaultProps = {
  className: "",
  isLabelWrapped: false,
  isValid: true,
  isDisabled: false,
  isRequired: false,
  isChecked: false,
  onChange: defaultOnChange,
  ouiaSafe: true
};

// node_modules/@patternfly/react-core/dist/esm/components/Menu/MenuItemAction.js
var import_jsx_runtime22 = __toESM(require_jsx_runtime());
var import_react20 = __toESM(require_react());
var MenuItemActionBase = (_a) => {
  var { className, icon, onClick, "aria-label": ariaLabel, isFavorited = null, isDisabled, actionId, innerRef } = _a, props = __rest(_a, ["className", "icon", "onClick", "aria-label", "isFavorited", "isDisabled", "actionId", "innerRef"]);
  return (0, import_jsx_runtime22.jsx)(MenuContext.Consumer, { children: ({ onActionClick }) => (0, import_jsx_runtime22.jsx)(MenuItemContext.Consumer, { children: ({ itemId, isDisabled: isDisabledContext }) => {
    const onClickButton = (event) => {
      onClick && onClick(event);
      onActionClick && onActionClick(event, itemId, actionId);
    };
    return (0, import_jsx_runtime22.jsx)("div", Object.assign({ className: css(menu_default.menuItemAction, isFavorited !== null && "pf-m-favorite", isFavorited && menu_default.modifiers.favorited, className) }, props, { children: (0, import_jsx_runtime22.jsx)(Button, { "aria-label": ariaLabel, onClick: onClickButton, ref: innerRef, role: "menuitem", variant: "plain", tabIndex: -1, isDisabled: isDisabled || isDisabledContext, icon: icon === "favorites" || isFavorited !== null ? (0, import_jsx_runtime22.jsx)(star_icon_default, {}) : icon }) }));
  } }) });
};
var MenuItemAction = (0, import_react20.forwardRef)((props, ref) => (0, import_jsx_runtime22.jsx)(MenuItemActionBase, Object.assign({}, props, { innerRef: ref })));
MenuItemAction.displayName = "MenuItemAction";

// node_modules/@patternfly/react-core/dist/esm/components/Menu/MenuItem.js
var import_jsx_runtime23 = __toESM(require_jsx_runtime());
var import_react21 = __toESM(require_react());

// node_modules/@patternfly/react-tokens/dist/esm/c_menu_m_flyout__menu_top_offset.js
var c_menu_m_flyout__menu_top_offset = {
  "name": "--pf-v6-c-menu--m-flyout__menu--top-offset",
  "value": "0px",
  "var": "var(--pf-v6-c-menu--m-flyout__menu--top-offset)"
};
var c_menu_m_flyout_menu_top_offset_default = c_menu_m_flyout__menu_top_offset;

// node_modules/@patternfly/react-tokens/dist/esm/c_menu_m_flyout__menu_m_left_right_offset.js
var c_menu_m_flyout__menu_m_left_right_offset = {
  "name": "--pf-v6-c-menu--m-flyout__menu--m-left--right-offset",
  "value": "0px",
  "var": "var(--pf-v6-c-menu--m-flyout__menu--m-left--right-offset)"
};
var c_menu_m_flyout_menu_m_left_right_offset_default = c_menu_m_flyout__menu_m_left_right_offset;

// node_modules/@patternfly/react-tokens/dist/esm/c_menu_m_flyout__menu_left_offset.js
var c_menu_m_flyout__menu_left_offset = {
  "name": "--pf-v6-c-menu--m-flyout__menu--left-offset",
  "value": "0px",
  "var": "var(--pf-v6-c-menu--m-flyout__menu--left-offset)"
};
var c_menu_m_flyout_menu_left_offset_default = c_menu_m_flyout__menu_left_offset;

// node_modules/@patternfly/react-core/dist/esm/components/Menu/MenuItem.js
var FlyoutContext = (0, import_react21.createContext)({
  direction: "right"
});
var MenuItemBase = (_a) => {
  var { children, className, itemId = null, to, hasCheckbox = false, isActive = null, isFavorited = null, isLoadButton = false, isLoading = false, flyoutMenu, direction, description = null, onClick = () => {
  }, component = "button", isDisabled = false, isAriaDisabled = false, isExternalLink = false, isSelected = null, isFocused, isDanger = false, icon, actions, onShowFlyout, drilldownMenu, isOnPath, innerRef, id, "aria-label": ariaLabel, tooltipProps, rel, target, download } = _a, props = __rest(_a, ["children", "className", "itemId", "to", "hasCheckbox", "isActive", "isFavorited", "isLoadButton", "isLoading", "flyoutMenu", "direction", "description", "onClick", "component", "isDisabled", "isAriaDisabled", "isExternalLink", "isSelected", "isFocused", "isDanger", "icon", "actions", "onShowFlyout", "drilldownMenu", "isOnPath", "innerRef", "id", "aria-label", "tooltipProps", "rel", "target", "download"]);
  const { menuId, parentMenu, onSelect, onActionClick, activeItemId, selected, drilldownItemPath, onDrillIn, onDrillOut, flyoutRef, setFlyoutRef, disableHover, role: menuRole } = (0, import_react21.useContext)(MenuContext);
  let Component9 = to ? "a" : component;
  if (hasCheckbox && !to) {
    Component9 = "label";
  }
  const [flyoutTarget, setFlyoutTarget] = (0, import_react21.useState)(null);
  const flyoutContext = (0, import_react21.useContext)(FlyoutContext);
  const [flyoutXDirection, setFlyoutXDirection] = (0, import_react21.useState)(flyoutContext.direction);
  const ref = (0, import_react21.useRef)(void 0);
  const privateRef = (0, import_react21.useRef)(void 0);
  const innerComponentRef = innerRef || privateRef;
  const flyoutVisible = ref === flyoutRef;
  const hasFlyout = flyoutMenu !== void 0;
  const showFlyout = (show) => {
    if (!flyoutVisible && show) {
      setFlyoutRef(ref);
    } else if (flyoutVisible && !show) {
      setFlyoutRef(null);
    }
    onShowFlyout && show && onShowFlyout();
  };
  useIsomorphicLayoutEffect(() => {
    if (hasFlyout && ref.current && canUseDOM) {
      const flyoutMenu2 = ref.current.lastElementChild;
      if (flyoutMenu2 && flyoutMenu2.classList.contains(menu_default.menu)) {
        const origin = ref.current.getClientRects()[0];
        const rect = flyoutMenu2.getClientRects()[0];
        if (origin && rect) {
          const spaceLeftLeft = origin.x - rect.width;
          const spaceLeftRight = window.innerWidth - origin.x - origin.width - rect.width;
          let xDir = flyoutXDirection;
          if (spaceLeftRight < 0 && xDir !== "left") {
            setFlyoutXDirection("left");
            xDir = "left";
          } else if (spaceLeftLeft < 0 && xDir !== "right") {
            setFlyoutXDirection("right");
            xDir = "right";
          }
          let xOffset = 0;
          if (spaceLeftLeft < 0 && spaceLeftRight < 0) {
            xOffset = xDir === "right" ? -spaceLeftRight : -spaceLeftLeft;
          }
          if (xDir === "left") {
            flyoutMenu2.classList.add(menu_default.modifiers.left);
            flyoutMenu2.style.setProperty(c_menu_m_flyout_menu_m_left_right_offset_default.name, `-${xOffset}px`);
          } else {
            flyoutMenu2.style.setProperty(c_menu_m_flyout_menu_left_offset_default.name, `-${xOffset}px`);
          }
          const spaceLeftBot = window.innerHeight - origin.y - rect.height;
          const spaceLeftTop = window.innerHeight - rect.height;
          if (spaceLeftTop < 0 && spaceLeftBot < 0) {
          } else if (spaceLeftBot < 0) {
            flyoutMenu2.style.setProperty(c_menu_m_flyout_menu_top_offset_default.name, `${spaceLeftBot}px`);
          }
        }
      }
    }
  }, [flyoutVisible, flyoutMenu]);
  (0, import_react21.useEffect)(() => {
    setFlyoutXDirection(flyoutContext.direction);
  }, [flyoutContext]);
  (0, import_react21.useEffect)(() => {
    if (flyoutTarget) {
      if (flyoutVisible) {
        const flyoutMenu2 = flyoutTarget.nextElementSibling;
        const flyoutItems = Array.from(flyoutMenu2.getElementsByTagName("UL")[0].children).filter((el) => !(el.classList.contains("pf-m-disabled") || el.classList.contains(menu_default.divider)));
        flyoutItems[0].firstChild.focus();
      } else {
        flyoutTarget.focus();
      }
    }
  }, [flyoutVisible, flyoutTarget]);
  const handleFlyout = (event) => {
    const key = event.key;
    const target2 = event.target;
    const type = event.type;
    if (key === " " || key === "Enter" || key === "ArrowRight" || type === "click") {
      event.stopPropagation();
      event.preventDefault();
      if (!flyoutVisible) {
        showFlyout(true);
        setFlyoutTarget(target2);
      }
    }
    if (key === "Escape" || key === "ArrowLeft") {
      if (flyoutVisible) {
        event.stopPropagation();
        showFlyout(false);
      }
    }
  };
  const onItemSelect = (event, onSelect2) => {
    if (!isAriaDisabled) {
      onSelect2 && onSelect2(event, itemId);
      onClick && onClick(event);
    }
  };
  const _isOnPath = isOnPath && isOnPath || drilldownItemPath && drilldownItemPath.includes(itemId) || false;
  let drill;
  if (direction) {
    if (direction === "down") {
      drill = (event) => onDrillIn && onDrillIn(event, menuId, typeof drilldownMenu === "function" ? drilldownMenu().props.id : drilldownMenu.props.id, itemId);
    } else {
      drill = (event) => onDrillOut && onDrillOut(event, parentMenu, itemId);
    }
  }
  let additionalProps = {};
  if (Component9 === "a") {
    additionalProps = {
      href: to,
      "aria-disabled": isDisabled || isAriaDisabled ? true : null,
      // prevent invalid 'disabled' attribute on <a> tags
      disabled: null,
      target: isExternalLink ? "_blank" : target,
      rel,
      download
    };
  } else if (Component9 === "button") {
    additionalProps = {
      type: "button",
      "aria-disabled": isAriaDisabled ? true : null
    };
  }
  if (isOnPath) {
    additionalProps["aria-expanded"] = true;
  } else if (hasFlyout) {
    additionalProps["aria-haspopup"] = "menu";
    additionalProps["aria-expanded"] = flyoutVisible;
  }
  const getAriaCurrent = () => {
    if (isActive !== null) {
      if (isActive) {
        return "page";
      } else {
        return null;
      }
    } else if (itemId !== null && activeItemId !== null) {
      return itemId === activeItemId;
    }
    return null;
  };
  const getIsSelected = () => {
    if (isSelected !== null) {
      return isSelected;
    } else if (selected !== null && itemId !== null) {
      return Array.isArray(selected) && selected.includes(itemId) || itemId === selected;
    }
    return false;
  };
  const onMouseOver = () => {
    if (disableHover) {
      return;
    }
    if (hasFlyout) {
      showFlyout(true);
    } else {
      setFlyoutRef(null);
    }
  };
  (0, import_react21.useEffect)(() => {
    if (isFocused && ref.current) {
      const itemEl = ref.current;
      const parentListEl = itemEl.parentElement;
      if (parentListEl) {
        const isAboveTop = itemEl.offsetTop - parentListEl.offsetTop < parentListEl.scrollTop;
        const isBelowBottom = itemEl.offsetTop - parentListEl.offsetTop + itemEl.clientHeight;
        if (isAboveTop || isBelowBottom) {
          itemEl.scrollIntoView({ behavior: "auto", block: "nearest" });
        }
      }
    }
  }, [isFocused]);
  const isSelectMenu = menuRole === "listbox";
  const renderItem = (0, import_jsx_runtime23.jsxs)(import_jsx_runtime23.Fragment, { children: [(0, import_jsx_runtime23.jsx)(GenerateId, { children: (randomId) => (0, import_jsx_runtime23.jsxs)(Component9, Object.assign({ id, tabIndex: -1, className: css(menu_default.menuItem, getIsSelected() && !hasCheckbox && menu_default.modifiers.selected, className), "aria-current": getAriaCurrent() }, !hasCheckbox && { disabled: isDisabled, "aria-label": ariaLabel }, !hasCheckbox && !flyoutMenu && { role: isSelectMenu ? "option" : "menuitem" }, !hasCheckbox && !flyoutMenu && isSelectMenu && { "aria-selected": getIsSelected() }, { ref: innerComponentRef }, !hasCheckbox && {
    onClick: (event) => {
      if (!isAriaDisabled) {
        onItemSelect(event, onSelect);
        drill && drill(event);
        flyoutMenu && handleFlyout(event);
      } else {
        event.preventDefault();
      }
    }
  }, hasCheckbox && { htmlFor: randomId }, additionalProps, { children: [(0, import_jsx_runtime23.jsxs)("span", { className: css(menu_default.menuItemMain), children: [direction === "up" && (0, import_jsx_runtime23.jsx)("span", { className: css(menu_default.menuItemToggleIcon), children: (0, import_jsx_runtime23.jsx)(angle_left_icon_default, {}) }), icon && (0, import_jsx_runtime23.jsx)("span", { className: css(menu_default.menuItemIcon), children: icon }), hasCheckbox && (0, import_jsx_runtime23.jsx)("span", { className: css(menu_default.menuItemCheck), children: (0, import_jsx_runtime23.jsx)(Checkbox, { id: randomId, component: "span", isChecked: isSelected || false, onChange: (event) => onItemSelect(event, onSelect), isDisabled, "aria-disabled": isAriaDisabled }) }), (0, import_jsx_runtime23.jsx)("span", { className: css(menu_default.menuItemText), children }), isExternalLink && (0, import_jsx_runtime23.jsx)("span", { className: css(menu_default.menuItemExternalIcon), children: (0, import_jsx_runtime23.jsx)(external_link_alt_icon_default, {}) }), (flyoutMenu || direction === "down") && (0, import_jsx_runtime23.jsx)("span", { className: css(menu_default.menuItemToggleIcon), children: (0, import_jsx_runtime23.jsx)(angle_right_icon_default, {}) }), getIsSelected() && (0, import_jsx_runtime23.jsx)("span", { className: css(menu_default.menuItemSelectIcon), children: (0, import_jsx_runtime23.jsx)(check_icon_default, {}) })] }), description && direction !== "up" && (0, import_jsx_runtime23.jsx)("span", { className: css(menu_default.menuItemDescription), children: (0, import_jsx_runtime23.jsx)("span", { children: description }) })] })) }), flyoutVisible && (0, import_jsx_runtime23.jsx)(MenuContext.Provider, { value: { disableHover }, children: (0, import_jsx_runtime23.jsx)(FlyoutContext.Provider, { value: { direction: flyoutXDirection }, children: flyoutMenu }) }), typeof drilldownMenu === "function" ? drilldownMenu() : drilldownMenu, (0, import_jsx_runtime23.jsxs)(MenuItemContext.Provider, { value: { itemId, isDisabled }, children: [actions, isFavorited !== null && (0, import_jsx_runtime23.jsx)(MenuItemAction, { icon: "favorites", isFavorited, "aria-label": isFavorited ? "starred" : "not starred", onClick: (event) => onActionClick(event, itemId), tabIndex: -1, actionId: "fav" })] })] });
  return (0, import_jsx_runtime23.jsxs)(import_jsx_runtime23.Fragment, { children: [(0, import_jsx_runtime23.jsx)("li", Object.assign({ className: css(menu_default.menuListItem, isDisabled && menu_default.modifiers.disabled, isAriaDisabled && menu_default.modifiers.ariaDisabled, _isOnPath && menu_default.modifiers.currentPath, isLoadButton && menu_default.modifiers.load, isLoading && menu_default.modifiers.loading, isFocused && "pf-m-focus", isDanger && menu_default.modifiers.danger, className), onMouseOver: () => {
    if (!isAriaDisabled) {
      onMouseOver();
    }
  } }, flyoutMenu && !isAriaDisabled && { onKeyDown: handleFlyout }, { ref, role: !hasCheckbox ? "none" : "menuitem" }, hasCheckbox && { "aria-label": ariaLabel }, props, { children: renderItem })), tooltipProps && (0, import_jsx_runtime23.jsx)(Tooltip, Object.assign({}, tooltipProps, { triggerRef: innerComponentRef }))] });
};
var MenuItem = (0, import_react21.forwardRef)((props, ref) => (0, import_jsx_runtime23.jsx)(MenuItemBase, Object.assign({}, props, { innerRef: ref })));
MenuItem.displayName = "MenuItem";

// node_modules/@patternfly/react-core/dist/esm/components/Menu/MenuList.js
var import_jsx_runtime24 = __toESM(require_jsx_runtime());
var import_react22 = __toESM(require_react());
var MenuList = (_a) => {
  var { children = null, className, isAriaMultiselectable = false, "aria-label": ariaLabel } = _a, props = __rest(_a, ["children", "className", "isAriaMultiselectable", "aria-label"]);
  const { role } = (0, import_react22.useContext)(MenuContext);
  return (0, import_jsx_runtime24.jsx)("ul", Object.assign({ role }, role === "listbox" && { "aria-multiselectable": isAriaMultiselectable }, { className: css(menu_default.menuList, className), "aria-label": ariaLabel }, props, { children }));
};
MenuList.displayName = "MenuList";

// node_modules/@patternfly/react-core/dist/esm/components/Menu/DrilldownMenu.js
var import_jsx_runtime25 = __toESM(require_jsx_runtime());
var import_react23 = __toESM(require_react());
var DrilldownMenu = (_a) => {
  var { children, id, isMenuDrilledIn = false, getHeight } = _a, props = __rest(_a, ["children", "id", "isMenuDrilledIn", "getHeight"]);
  return (
    /* eslint-disable @typescript-eslint/no-unused-vars */
    (0, import_jsx_runtime25.jsx)(MenuContext.Consumer, { children: (_a2) => {
      var { menuId, parentMenu, flyoutRef, setFlyoutRef, disableHover } = _a2, context = __rest(_a2, ["menuId", "parentMenu", "flyoutRef", "setFlyoutRef", "disableHover"]);
      return (0, import_jsx_runtime25.jsx)(Menu, Object.assign({ id, parentMenu: menuId, isMenuDrilledIn, isRootMenu: false, ref: (0, import_react23.createRef)() }, context, props, { children: (0, import_jsx_runtime25.jsx)(MenuContent, { getHeight, children: (0, import_jsx_runtime25.jsx)(MenuList, { children }) }) }));
    } })
  );
};
DrilldownMenu.displayName = "DrilldownMenu";

// node_modules/@patternfly/react-core/dist/esm/components/Menu/MenuBreadcrumb.js
var import_jsx_runtime26 = __toESM(require_jsx_runtime());
var MenuBreadcrumb = (_a) => {
  var { children } = _a, props = __rest(_a, ["children"]);
  return (0, import_jsx_runtime26.jsx)("div", Object.assign({ className: css(menu_default.menuBreadcrumb) }, props, { children }));
};
MenuBreadcrumb.displayName = "MenuBreadcrumb";

// node_modules/@patternfly/react-core/dist/esm/components/Menu/MenuContainer.js
var import_jsx_runtime27 = __toESM(require_jsx_runtime());
var import_react24 = __toESM(require_react());
var MenuContainer = ({ menu, menuRef, isOpen, toggle, toggleRef, onOpenChange, onToggleKeydown, zIndex = 9999, popperProps, onOpenChangeKeys = ["Escape", "Tab"], shouldFocusFirstItemOnOpen = false, shouldPreventScrollOnItemFocus = true, focusTimeoutDelay = 0 }) => {
  const prevIsOpen = (0, import_react24.useRef)(isOpen);
  (0, import_react24.useEffect)(() => {
    if (prevIsOpen.current === false && isOpen === true && shouldFocusFirstItemOnOpen) {
      setTimeout(() => {
        var _a;
        const firstElement = (_a = menuRef === null || menuRef === void 0 ? void 0 : menuRef.current) === null || _a === void 0 ? void 0 : _a.querySelector('li button:not(:disabled),li input:not(:disabled),li a:not([aria-disabled="true"])');
        firstElement && firstElement.focus({ preventScroll: shouldPreventScrollOnItemFocus });
      }, focusTimeoutDelay);
    }
    prevIsOpen.current = isOpen;
  }, [isOpen]);
  (0, import_react24.useEffect)(() => {
    const handleMenuKeys = (event) => {
      var _a, _b, _c, _d;
      if (isOpen && onOpenChange && ((_a = menuRef.current) === null || _a === void 0 ? void 0 : _a.contains(event.target)) || ((_b = toggleRef.current) === null || _b === void 0 ? void 0 : _b.contains(event.target))) {
        if (onOpenChangeKeys.includes(event.key)) {
          onOpenChange(false);
          (_c = toggleRef.current) === null || _c === void 0 ? void 0 : _c.focus();
        }
      }
      if ((_d = toggleRef.current) === null || _d === void 0 ? void 0 : _d.contains(event.target)) {
        if (onToggleKeydown) {
          onToggleKeydown(event);
        } else if (isOpen) {
          onToggleArrowKeydownDefault(event, menuRef);
        }
      }
    };
    const handleClick = (event) => {
      var _a, _b;
      if (isOpen && onOpenChange && !((_a = toggleRef === null || toggleRef === void 0 ? void 0 : toggleRef.current) === null || _a === void 0 ? void 0 : _a.contains(event.target))) {
        if (isOpen && !((_b = menuRef.current) === null || _b === void 0 ? void 0 : _b.contains(event.target))) {
          onOpenChange(false);
        }
      }
    };
    window.addEventListener("keydown", handleMenuKeys);
    window.addEventListener("click", handleClick);
    return () => {
      window.removeEventListener("keydown", handleMenuKeys);
      window.removeEventListener("click", handleClick);
    };
  }, [
    focusTimeoutDelay,
    isOpen,
    menuRef,
    onOpenChange,
    onOpenChangeKeys,
    onToggleKeydown,
    shouldPreventScrollOnItemFocus,
    toggleRef
  ]);
  return (0, import_jsx_runtime27.jsx)(Popper, Object.assign({ trigger: toggle, triggerRef: toggleRef, popper: menu, popperRef: menuRef, isVisible: isOpen, zIndex }, popperProps));
};
MenuContainer.displayName = "MenuContainer";

// node_modules/@patternfly/react-core/dist/esm/components/Select/Select.js
var import_jsx_runtime28 = __toESM(require_jsx_runtime());
var import_react25 = __toESM(require_react());
var SelectBase = (_a) => {
  var { children, className, onSelect, isOpen, selected, toggle, shouldFocusToggleOnSelect = false, shouldFocusFirstItemOnOpen = false, onOpenChange, onOpenChangeKeys = ["Escape", "Tab"], onToggleKeydown, variant, isPlain, innerRef, zIndex = 9999, role = "listbox", popperProps, menuHeight, maxMenuHeight, isScrollable, shouldPreventScrollOnItemFocus = true, focusTimeoutDelay = 0 } = _a, props = __rest(_a, ["children", "className", "onSelect", "isOpen", "selected", "toggle", "shouldFocusToggleOnSelect", "shouldFocusFirstItemOnOpen", "onOpenChange", "onOpenChangeKeys", "onToggleKeydown", "variant", "isPlain", "innerRef", "zIndex", "role", "popperProps", "menuHeight", "maxMenuHeight", "isScrollable", "shouldPreventScrollOnItemFocus", "focusTimeoutDelay"]);
  const localMenuRef = (0, import_react25.useRef)(void 0);
  const localToggleRef = (0, import_react25.useRef)(void 0);
  const menuRef = innerRef || localMenuRef;
  const toggleRef = typeof toggle === "function" || typeof toggle !== "function" && !toggle.toggleRef ? localToggleRef : toggle === null || toggle === void 0 ? void 0 : toggle.toggleRef;
  const prevIsOpen = (0, import_react25.useRef)(isOpen);
  (0, import_react25.useEffect)(() => {
    if (prevIsOpen.current === false && isOpen === true && shouldFocusFirstItemOnOpen) {
      setTimeout(() => {
        var _a2;
        const firstElement = (_a2 = menuRef === null || menuRef === void 0 ? void 0 : menuRef.current) === null || _a2 === void 0 ? void 0 : _a2.querySelector("li button:not(:disabled),li input:not(:disabled)");
        firstElement && firstElement.focus({ preventScroll: shouldPreventScrollOnItemFocus });
      }, focusTimeoutDelay);
    }
    prevIsOpen.current = isOpen;
  }, [isOpen]);
  (0, import_react25.useEffect)(() => {
    const handleMenuKeys = (event) => {
      var _a2, _b, _c, _d;
      if (isOpen && onOpenChange && (((_a2 = menuRef.current) === null || _a2 === void 0 ? void 0 : _a2.contains(event.target)) || ((_b = toggleRef.current) === null || _b === void 0 ? void 0 : _b.contains(event.target)))) {
        if (onOpenChangeKeys.includes(event.key)) {
          event.preventDefault();
          onOpenChange(false);
          (_c = toggleRef.current) === null || _c === void 0 ? void 0 : _c.focus();
        }
      }
      if ((_d = toggleRef.current) === null || _d === void 0 ? void 0 : _d.contains(event.target)) {
        if (onToggleKeydown) {
          onToggleKeydown(event);
        } else if (isOpen && variant !== "typeahead") {
          onToggleArrowKeydownDefault(event, menuRef);
        }
      }
    };
    const handleClick = (event) => {
      var _a2, _b;
      if (isOpen && onOpenChange && !((_a2 = toggleRef === null || toggleRef === void 0 ? void 0 : toggleRef.current) === null || _a2 === void 0 ? void 0 : _a2.contains(event.target))) {
        if (isOpen && !((_b = menuRef.current) === null || _b === void 0 ? void 0 : _b.contains(event.target))) {
          onOpenChange(false);
        }
      }
    };
    window.addEventListener("keydown", handleMenuKeys);
    window.addEventListener("click", handleClick);
    return () => {
      window.removeEventListener("keydown", handleMenuKeys);
      window.removeEventListener("click", handleClick);
    };
  }, [
    isOpen,
    menuRef,
    toggleRef,
    onOpenChange,
    onOpenChangeKeys,
    onToggleKeydown,
    shouldPreventScrollOnItemFocus,
    shouldFocusFirstItemOnOpen,
    focusTimeoutDelay
  ]);
  const menu = (0, import_jsx_runtime28.jsx)(Menu, Object.assign({ role, className: css(className), ref: menuRef, onSelect: (event, value) => {
    onSelect && onSelect(event, value);
    shouldFocusToggleOnSelect && toggleRef.current.focus();
  }, isPlain, selected, isScrollable: isScrollable !== null && isScrollable !== void 0 ? isScrollable : menuHeight !== void 0 || maxMenuHeight !== void 0 }, getOUIAProps(Select.displayName, props.ouiaId !== void 0 ? props.ouiaId : getDefaultOUIAId(Select.displayName), props.ouiaSafe !== void 0 ? props.ouiaSafe : true), props, { children: (0, import_jsx_runtime28.jsx)(MenuContent, { menuHeight, maxMenuHeight, children }) }));
  return (0, import_jsx_runtime28.jsx)(Popper, Object.assign({ trigger: typeof toggle === "function" ? toggle(toggleRef) : toggle.toggleNode, triggerRef: toggleRef, popper: menu, popperRef: menuRef, isVisible: isOpen, zIndex }, popperProps));
};
var Select = (0, import_react25.forwardRef)((props, ref) => (0, import_jsx_runtime28.jsx)(SelectBase, Object.assign({ innerRef: ref }, props)));
Select.displayName = "Select";

// node_modules/@patternfly/react-core/dist/esm/components/Select/SelectGroup.js
var import_jsx_runtime29 = __toESM(require_jsx_runtime());
var SelectGroup = (_a) => {
  var { children, className, label } = _a, props = __rest(_a, ["children", "className", "label"]);
  return (0, import_jsx_runtime29.jsx)(MenuGroup, Object.assign({ className: css(className), label }, props, { children }));
};
SelectGroup.displayName = "SelectGroup";

// node_modules/@patternfly/react-core/dist/esm/components/Select/SelectList.js
var import_jsx_runtime30 = __toESM(require_jsx_runtime());
var SelectList = (_a) => {
  var { children, className, isAriaMultiselectable = false } = _a, props = __rest(_a, ["children", "className", "isAriaMultiselectable"]);
  return (0, import_jsx_runtime30.jsx)(MenuList, Object.assign({ isAriaMultiselectable, className: css(className) }, props, { children }));
};
SelectList.displayName = "SelectList";

// node_modules/@patternfly/react-core/dist/esm/components/Select/SelectOption.js
var import_jsx_runtime31 = __toESM(require_jsx_runtime());
var import_react26 = __toESM(require_react());
var SelectOptionBase = (_a) => {
  var { children, className, innerRef, value } = _a, props = __rest(_a, ["children", "className", "innerRef", "value"]);
  return (0, import_jsx_runtime31.jsx)(MenuItem, Object.assign({ itemId: value, ref: innerRef, className: css(className) }, props, { children }));
};
var SelectOption = (0, import_react26.forwardRef)((props, ref) => (0, import_jsx_runtime31.jsx)(SelectOptionBase, Object.assign({}, props, { innerRef: ref })));
SelectOption.displayName = "SelectOption";

// node_modules/@patternfly/react-core/dist/esm/components/MenuToggle/MenuToggle.js
var import_jsx_runtime32 = __toESM(require_jsx_runtime());
var import_react27 = __toESM(require_react());

// node_modules/@patternfly/react-styles/css/components/MenuToggle/menu-toggle.mjs
import "/Users/pamparan/Desktop/Edge - AI Design support  /amplify-edge/frontend/node_modules/@patternfly/react-styles/css/components/MenuToggle/menu-toggle.css";
var menu_toggle_default = {
  "avatar": "pf-v6-c-avatar",
  "button": "pf-v6-c-button",
  "check": "pf-v6-c-check",
  "checkInput": "pf-v6-c-check__input",
  "menuToggle": "pf-v6-c-menu-toggle",
  "menuToggleButton": "pf-v6-c-menu-toggle__button",
  "menuToggleControls": "pf-v6-c-menu-toggle__controls",
  "menuToggleCount": "pf-v6-c-menu-toggle__count",
  "menuToggleIcon": "pf-v6-c-menu-toggle__icon",
  "menuToggleStatusIcon": "pf-v6-c-menu-toggle__status-icon",
  "menuToggleText": "pf-v6-c-menu-toggle__text",
  "menuToggleToggleIcon": "pf-v6-c-menu-toggle__toggle-icon",
  "modifiers": {
    "primary": "pf-m-primary",
    "secondary": "pf-m-secondary",
    "fullHeight": "pf-m-full-height",
    "fullWidth": "pf-m-full-width",
    "plain": "pf-m-plain",
    "expanded": "pf-m-expanded",
    "disabled": "pf-m-disabled",
    "small": "pf-m-small",
    "success": "pf-m-success",
    "warning": "pf-m-warning",
    "danger": "pf-m-danger",
    "settings": "pf-m-settings",
    "placeholder": "pf-m-placeholder",
    "splitButton": "pf-m-split-button",
    "standalone": "pf-m-standalone",
    "typeahead": "pf-m-typeahead",
    "text": "pf-m-text",
    "avatar": "pf-m-avatar"
  },
  "textInputGroup": "pf-v6-c-text-input-group"
};

// node_modules/@patternfly/react-core/dist/esm/components/MenuToggle/MenuToggle.js
var MenuToggleStatus;
(function(MenuToggleStatus2) {
  MenuToggleStatus2["success"] = "success";
  MenuToggleStatus2["danger"] = "danger";
  MenuToggleStatus2["warning"] = "warning";
})(MenuToggleStatus || (MenuToggleStatus = {}));
var MenuToggleSize;
(function(MenuToggleSize2) {
  MenuToggleSize2["default"] = "default";
  MenuToggleSize2["sm"] = "sm";
})(MenuToggleSize || (MenuToggleSize = {}));
var MenuToggleBase = class extends import_react27.Component {
  constructor() {
    super(...arguments);
    this.displayName = "MenuToggleBase";
    this.state = {
      ouiaStateId: getDefaultOUIAId(MenuToggle.displayName, this.props.variant)
    };
  }
  render() {
    const _a = this.props, { children, className, icon, badge, isExpanded, isDisabled, isFullHeight, isFullWidth, isPlaceholder, isSettings, splitButtonItems, variant, status, statusIcon, innerRef, onClick, "aria-label": ariaLabel, ouiaId, ouiaSafe, size } = _a, otherProps = __rest(_a, ["children", "className", "icon", "badge", "isExpanded", "isDisabled", "isFullHeight", "isFullWidth", "isPlaceholder", "isSettings", "splitButtonItems", "variant", "status", "statusIcon", "innerRef", "onClick", "aria-label", "ouiaId", "ouiaSafe", "size"]);
    const isPlain = variant === "plain";
    const isPlainText = variant === "plainText";
    const isTypeahead = variant === "typeahead";
    const ouiaProps = getOUIAProps(MenuToggle.displayName, ouiaId !== null && ouiaId !== void 0 ? ouiaId : this.state.ouiaStateId, ouiaSafe);
    let _statusIcon = statusIcon;
    if (!statusIcon) {
      switch (status) {
        case MenuToggleStatus.success:
          _statusIcon = (0, import_jsx_runtime32.jsx)(check_circle_icon_default, {});
          break;
        case MenuToggleStatus.warning:
          _statusIcon = (0, import_jsx_runtime32.jsx)(exclamation_triangle_icon_default, {});
          break;
        case MenuToggleStatus.danger:
          _statusIcon = (0, import_jsx_runtime32.jsx)(exclamation_circle_icon_default, {});
          break;
      }
    }
    const toggleControls = (0, import_jsx_runtime32.jsxs)("span", { className: css(menu_toggle_default.menuToggleControls), children: [status !== void 0 && (0, import_jsx_runtime32.jsx)("span", { className: css(menu_toggle_default.menuToggleStatusIcon), children: _statusIcon }), (0, import_jsx_runtime32.jsx)("span", { className: css(menu_toggle_default.menuToggleToggleIcon), children: (0, import_jsx_runtime32.jsx)(caret_down_icon_default, {}) })] });
    const content = (0, import_jsx_runtime32.jsxs)(import_jsx_runtime32.Fragment, { children: [(icon || isSettings) && (0, import_jsx_runtime32.jsx)("span", { className: css(menu_toggle_default.menuToggleIcon), children: isSettings ? (0, import_jsx_runtime32.jsx)(cog_icon_default, {}) : icon }), isTypeahead ? children : children && (0, import_jsx_runtime32.jsx)("span", { className: css(menu_toggle_default.menuToggleText), children }), (0, import_react27.isValidElement)(badge) && (0, import_jsx_runtime32.jsx)("span", { className: css(menu_toggle_default.menuToggleCount), children: badge }), isTypeahead ? (0, import_jsx_runtime32.jsx)("button", Object.assign({ type: "button", className: css(menu_toggle_default.menuToggleButton), "aria-expanded": isExpanded, onClick, "aria-label": ariaLabel || "Menu toggle", tabIndex: -1 }, ouiaProps, { children: toggleControls })) : !isPlain && toggleControls] });
    const commonStyles = css(menu_toggle_default.menuToggle, isExpanded && menu_toggle_default.modifiers.expanded, variant === "primary" && menu_toggle_default.modifiers.primary, variant === "secondary" && menu_toggle_default.modifiers.secondary, status && menu_toggle_default.modifiers[status], (isPlain || isPlainText) && menu_toggle_default.modifiers.plain, isPlainText && "pf-m-text", isFullHeight && menu_toggle_default.modifiers.fullHeight, isFullWidth && menu_toggle_default.modifiers.fullWidth, isDisabled && menu_toggle_default.modifiers.disabled, isPlaceholder && menu_toggle_default.modifiers.placeholder, isSettings && menu_toggle_default.modifiers.settings, size === MenuToggleSize.sm && menu_toggle_default.modifiers.small, className);
    const componentProps = Object.assign(Object.assign({ children: content }, isDisabled && { disabled: true }), otherProps);
    if (isTypeahead) {
      return (0, import_jsx_runtime32.jsx)("div", Object.assign({ ref: innerRef, className: css(commonStyles, menu_toggle_default.modifiers.typeahead) }, componentProps));
    }
    if (splitButtonItems) {
      return (0, import_jsx_runtime32.jsxs)("div", { ref: innerRef, className: css(commonStyles, menu_toggle_default.modifiers.splitButton), children: [splitButtonItems, (0, import_jsx_runtime32.jsxs)("button", Object.assign({ className: css(menu_toggle_default.menuToggleButton, children && menu_toggle_default.modifiers.text), type: "button", "aria-expanded": isExpanded, "aria-label": ariaLabel, disabled: isDisabled, onClick }, otherProps, ouiaProps, { children: [children && (0, import_jsx_runtime32.jsx)("span", { className: css(menu_toggle_default.menuToggleText), children }), toggleControls] }))] });
    }
    return (0, import_jsx_runtime32.jsx)("button", Object.assign({ className: css(commonStyles), type: "button", "aria-label": ariaLabel, "aria-expanded": isExpanded, ref: innerRef, disabled: isDisabled, onClick }, componentProps, ouiaProps));
  }
};
MenuToggleBase.defaultProps = {
  className: "",
  isExpanded: false,
  isDisabled: false,
  isFullWidth: false,
  isFullHeight: false,
  isPlaceholder: false,
  size: "default",
  ouiaSafe: true
};
var MenuToggle = (0, import_react27.forwardRef)((props, ref) => (0, import_jsx_runtime32.jsx)(MenuToggleBase, Object.assign({ innerRef: ref }, props)));
MenuToggle.displayName = "MenuToggle";

// node_modules/@patternfly/react-core/dist/esm/components/MenuToggle/MenuToggleAction.js
var import_jsx_runtime33 = __toESM(require_jsx_runtime());
var import_react28 = __toESM(require_react());
var MenuToggleAction = class extends import_react28.Component {
  render() {
    const _a = this.props, { id, className, onClick, isDisabled, children } = _a, props = __rest(_a, ["id", "className", "onClick", "isDisabled", "children"]);
    return (0, import_jsx_runtime33.jsx)("button", Object.assign({ id, className: css(menu_toggle_default.menuToggleButton, className), onClick, type: "button", disabled: isDisabled }, props, { children }));
  }
};
MenuToggleAction.displayName = "MenuToggleAction";
MenuToggleAction.defaultProps = {
  className: "",
  isDisabled: false,
  onClick: () => {
  }
};

// node_modules/@patternfly/react-core/dist/esm/components/MenuToggle/MenuToggleCheckbox.js
var import_jsx_runtime34 = __toESM(require_jsx_runtime());
var import_react29 = __toESM(require_react());
var MenuToggleCheckbox = class _MenuToggleCheckbox extends import_react29.Component {
  constructor(props) {
    super(props);
    this.handleChange = (event) => {
      this.props.onChange(event.target.checked, event);
    };
    this.calculateChecked = () => {
      const { isChecked, defaultChecked } = this.props;
      if (isChecked === null) {
        return false;
      } else if (isChecked !== void 0) {
        return isChecked;
      }
      return defaultChecked;
    };
    this.state = {
      ouiaStateId: getDefaultOUIAId(_MenuToggleCheckbox.displayName)
    };
  }
  render() {
    const _a = this.props, {
      className,
      isValid,
      isDisabled,
      isChecked,
      children,
      ouiaId,
      ouiaSafe,
      /* eslint-disable @typescript-eslint/no-unused-vars */
      onChange,
      defaultChecked,
      id
    } = _a, props = __rest(_a, ["className", "isValid", "isDisabled", "isChecked", "children", "ouiaId", "ouiaSafe", "onChange", "defaultChecked", "id"]);
    const text = children && (0, import_jsx_runtime34.jsx)("span", { className: css(check_default.checkLabel, className), "aria-hidden": "true", id, children });
    return (0, import_jsx_runtime34.jsxs)("label", { className: css(check_default.check, !children && check_default.modifiers.standalone, className), children: [(0, import_jsx_runtime34.jsx)("input", Object.assign({ className: css(check_default.checkInput) }, this.calculateChecked() !== void 0 && { onChange: this.handleChange }, { name: id, type: "checkbox", ref: (elem) => {
      elem && (elem.indeterminate = isChecked === null);
    }, "aria-invalid": !isValid, disabled: isDisabled }, defaultChecked !== void 0 ? { defaultChecked } : { checked: this.calculateChecked() }, getOUIAProps(_MenuToggleCheckbox.displayName, ouiaId !== void 0 ? ouiaId : this.state.ouiaStateId, ouiaSafe), props)), text] });
  }
};
MenuToggleCheckbox.displayName = "MenuToggleCheckbox";
MenuToggleCheckbox.defaultProps = {
  isValid: true,
  isDisabled: false,
  onChange: () => void 0
};

// node_modules/@patternfly/react-core/dist/esm/components/Popover/Popover.js
var import_jsx_runtime43 = __toESM(require_jsx_runtime());
var import_react31 = __toESM(require_react());

// node_modules/@patternfly/react-styles/css/components/Popover/popover.mjs
import "/Users/pamparan/Desktop/Edge - AI Design support  /amplify-edge/frontend/node_modules/@patternfly/react-styles/css/components/Popover/popover.css";
var popover_default = {
  "modifiers": {
    "noPadding": "pf-m-no-padding",
    "widthAuto": "pf-m-width-auto",
    "top": "pf-m-top",
    "topLeft": "pf-m-top-left",
    "topRight": "pf-m-top-right",
    "bottom": "pf-m-bottom",
    "bottomLeft": "pf-m-bottom-left",
    "bottomRight": "pf-m-bottom-right",
    "left": "pf-m-left",
    "leftTop": "pf-m-left-top",
    "leftBottom": "pf-m-left-bottom",
    "right": "pf-m-right",
    "rightTop": "pf-m-right-top",
    "rightBottom": "pf-m-right-bottom",
    "danger": "pf-m-danger",
    "warning": "pf-m-warning",
    "success": "pf-m-success",
    "custom": "pf-m-custom",
    "info": "pf-m-info"
  },
  "popover": "pf-v6-c-popover",
  "popoverArrow": "pf-v6-c-popover__arrow",
  "popoverBody": "pf-v6-c-popover__body",
  "popoverClose": "pf-v6-c-popover__close",
  "popoverContent": "pf-v6-c-popover__content",
  "popoverFooter": "pf-v6-c-popover__footer",
  "popoverHeader": "pf-v6-c-popover__header",
  "popoverTitle": "pf-v6-c-popover__title",
  "popoverTitleIcon": "pf-v6-c-popover__title-icon",
  "popoverTitleText": "pf-v6-c-popover__title-text"
};

// node_modules/@patternfly/react-core/dist/esm/components/Popover/PopoverContext.js
var import_react30 = __toESM(require_react());
var PopoverContext = (0, import_react30.createContext)({});

// node_modules/@patternfly/react-core/dist/esm/components/Popover/PopoverContent.js
var import_jsx_runtime35 = __toESM(require_jsx_runtime());
var PopoverContent = (_a) => {
  var { className = null, children } = _a, props = __rest(_a, ["className", "children"]);
  return (0, import_jsx_runtime35.jsx)("div", Object.assign({ className: css(popover_default.popoverContent, className) }, props, { children }));
};
PopoverContent.displayName = "PopoverContent";

// node_modules/@patternfly/react-core/dist/esm/components/Popover/PopoverBody.js
var import_jsx_runtime36 = __toESM(require_jsx_runtime());
var PopoverBody = (_a) => {
  var { children, id, className } = _a, props = __rest(_a, ["children", "id", "className"]);
  return (0, import_jsx_runtime36.jsx)("div", Object.assign({ className: css(popover_default.popoverBody, className), id }, props, { children }));
};
PopoverBody.displayName = "PopoverBody";

// node_modules/@patternfly/react-core/dist/esm/components/Popover/PopoverHeader.js
var import_jsx_runtime39 = __toESM(require_jsx_runtime());

// node_modules/@patternfly/react-core/dist/esm/components/Popover/PopoverHeaderIcon.js
var import_jsx_runtime37 = __toESM(require_jsx_runtime());
var PopoverHeaderIcon = (_a) => {
  var { children, className } = _a, props = __rest(_a, ["children", "className"]);
  return (0, import_jsx_runtime37.jsx)("span", Object.assign({ className: css(popover_default.popoverTitleIcon, className) }, props, { children }));
};
PopoverHeaderIcon.displayName = "PopoverHeaderIcon";

// node_modules/@patternfly/react-core/dist/esm/components/Popover/PopoverHeaderText.js
var import_jsx_runtime38 = __toESM(require_jsx_runtime());
var PopoverHeaderText = (_a) => {
  var { children, className, headingLevel } = _a, props = __rest(_a, ["children", "className", "headingLevel"]);
  const HeadingLevel = headingLevel;
  return (0, import_jsx_runtime38.jsx)(HeadingLevel, Object.assign({ className: css(popover_default.popoverTitleText, className) }, props, { children }));
};
PopoverHeaderText.displayName = "PopoverHeaderText";

// node_modules/@patternfly/react-core/dist/esm/components/Popover/PopoverHeader.js
var PopoverHeader = (_a) => {
  var { children, icon, className, titleHeadingLevel = "h6", alertSeverityVariant, id, alertSeverityScreenReaderText } = _a, props = __rest(_a, ["children", "icon", "className", "titleHeadingLevel", "alertSeverityVariant", "id", "alertSeverityScreenReaderText"]);
  return (0, import_jsx_runtime39.jsx)("header", Object.assign({ className: css(popover_default.popoverHeader, className) }, props, { children: (0, import_jsx_runtime39.jsxs)("div", { className: css(popover_default.popoverTitle), id, children: [icon && (0, import_jsx_runtime39.jsx)(PopoverHeaderIcon, { children: icon }), (0, import_jsx_runtime39.jsxs)(PopoverHeaderText, { headingLevel: titleHeadingLevel, children: [alertSeverityVariant && alertSeverityScreenReaderText && (0, import_jsx_runtime39.jsx)("span", { className: "pf-v6-screen-reader", children: alertSeverityScreenReaderText }), children] })] }) }));
};
PopoverHeader.displayName = "PopoverHeader";

// node_modules/@patternfly/react-core/dist/esm/components/Popover/PopoverFooter.js
var import_jsx_runtime40 = __toESM(require_jsx_runtime());
var PopoverFooter = (_a) => {
  var { children, className = "" } = _a, props = __rest(_a, ["children", "className"]);
  return (0, import_jsx_runtime40.jsx)("footer", Object.assign({ className: css(popover_default.popoverFooter, className) }, props, { children }));
};
PopoverFooter.displayName = "PopoverFooter";

// node_modules/@patternfly/react-core/dist/esm/components/Popover/PopoverCloseButton.js
var import_jsx_runtime41 = __toESM(require_jsx_runtime());
var PopoverCloseButton = (_a) => {
  var { onClose = () => void 0 } = _a, props = __rest(_a, ["onClose"]);
  return (0, import_jsx_runtime41.jsx)("div", { className: css(popover_default.popoverClose), children: (0, import_jsx_runtime41.jsx)(Button, Object.assign({ onClick: onClose, variant: "plain", "aria-label": true }, props, { style: { pointerEvents: "auto" }, icon: (0, import_jsx_runtime41.jsx)(times_icon_default, {}) })) });
};
PopoverCloseButton.displayName = "PopoverCloseButton";

// node_modules/@patternfly/react-core/dist/esm/components/Popover/PopoverArrow.js
var import_jsx_runtime42 = __toESM(require_jsx_runtime());
var PopoverArrow = (_a) => {
  var { className = "" } = _a, props = __rest(_a, ["className"]);
  return (0, import_jsx_runtime42.jsx)("div", Object.assign({ className: css(popover_default.popoverArrow, className) }, props));
};
PopoverArrow.displayName = "PopoverArrow";

// node_modules/@patternfly/react-tokens/dist/esm/c_popover_MaxWidth.js
var c_popover_MaxWidth = {
  "name": "--pf-v6-c-popover--MaxWidth",
  "value": "none",
  "var": "var(--pf-v6-c-popover--MaxWidth)"
};
var c_popover_MaxWidth_default = c_popover_MaxWidth;

// node_modules/@patternfly/react-tokens/dist/esm/c_popover_MinWidth.js
var c_popover_MinWidth = {
  "name": "--pf-v6-c-popover--MinWidth",
  "value": "auto",
  "var": "var(--pf-v6-c-popover--MinWidth)"
};
var c_popover_MinWidth_default = c_popover_MinWidth;

// node_modules/@patternfly/react-core/dist/esm/components/Popover/Popover.js
var PopoverPosition;
(function(PopoverPosition2) {
  PopoverPosition2["auto"] = "auto";
  PopoverPosition2["top"] = "top";
  PopoverPosition2["bottom"] = "bottom";
  PopoverPosition2["left"] = "left";
  PopoverPosition2["right"] = "right";
  PopoverPosition2["topStart"] = "top-start";
  PopoverPosition2["topEnd"] = "top-end";
  PopoverPosition2["bottomStart"] = "bottom-start";
  PopoverPosition2["bottomEnd"] = "bottom-end";
  PopoverPosition2["leftStart"] = "left-start";
  PopoverPosition2["leftEnd"] = "left-end";
  PopoverPosition2["rightStart"] = "right-start";
  PopoverPosition2["rightEnd"] = "right-end";
})(PopoverPosition || (PopoverPosition = {}));
var alertStyle = {
  custom: popover_default.modifiers.custom,
  info: popover_default.modifiers.info,
  success: popover_default.modifiers.success,
  warning: popover_default.modifiers.warning,
  danger: popover_default.modifiers.danger
};
var Popover = (_a) => {
  var { children, position = "top", enableFlip = true, className = "", isVisible = null, shouldClose = () => null, shouldOpen = () => null, "aria-label": ariaLabel = "", bodyContent, headerContent = null, headerComponent = "h6", headerIcon = null, alertSeverityVariant, alertSeverityScreenReaderText, footerContent = null, appendTo = () => document.body, hideOnOutsideClick = true, onHide = () => null, onHidden = () => null, onShow = () => null, onShown = () => null, onMount = () => null, zIndex = 9999, triggerAction = "click", minWidth = c_popover_MinWidth_default && c_popover_MinWidth_default.value, maxWidth = c_popover_MaxWidth_default && c_popover_MaxWidth_default.value, closeBtnAriaLabel = "Close", showClose = true, distance = 25, flipBehavior = [
    "top",
    "bottom",
    "left",
    "right",
    "top-start",
    "top-end",
    "bottom-start",
    "bottom-end",
    "left-start",
    "left-end",
    "right-start",
    "right-end"
  ], animationDuration = 300, id, withFocusTrap: propWithFocusTrap, triggerRef, hasNoPadding = false, hasAutoWidth = false, elementToFocus } = _a, rest = __rest(_a, ["children", "position", "enableFlip", "className", "isVisible", "shouldClose", "shouldOpen", "aria-label", "bodyContent", "headerContent", "headerComponent", "headerIcon", "alertSeverityVariant", "alertSeverityScreenReaderText", "footerContent", "appendTo", "hideOnOutsideClick", "onHide", "onHidden", "onShow", "onShown", "onMount", "zIndex", "triggerAction", "minWidth", "maxWidth", "closeBtnAriaLabel", "showClose", "distance", "flipBehavior", "animationDuration", "id", "withFocusTrap", "triggerRef", "hasNoPadding", "hasAutoWidth", "elementToFocus"]);
  const uniqueId = id || getUniqueId();
  const triggerManually = isVisible !== null;
  const [visible, setVisible] = (0, import_react31.useState)(false);
  const [focusTrapActive, setFocusTrapActive] = (0, import_react31.useState)(Boolean(propWithFocusTrap));
  const popoverRef = (0, import_react31.useRef)(null);
  (0, import_react31.useEffect)(() => {
    onMount();
  }, []);
  (0, import_react31.useEffect)(() => {
    if (triggerManually) {
      if (isVisible) {
        show(void 0, true);
      } else {
        hide2();
      }
    }
  }, [isVisible, triggerManually]);
  const show = (event, withFocusTrap) => {
    event && onShow(event);
    setVisible(true);
    propWithFocusTrap !== false && withFocusTrap && setFocusTrapActive(true);
  };
  const hide2 = (event) => {
    event && onHide(event);
    setVisible(false);
  };
  const positionModifiers = {
    top: popover_default.modifiers.top,
    bottom: popover_default.modifiers.bottom,
    left: popover_default.modifiers.left,
    right: popover_default.modifiers.right,
    "top-start": popover_default.modifiers.topLeft,
    "top-end": popover_default.modifiers.topRight,
    "bottom-start": popover_default.modifiers.bottomLeft,
    "bottom-end": popover_default.modifiers.bottomRight,
    "left-start": popover_default.modifiers.leftTop,
    "left-end": popover_default.modifiers.leftBottom,
    "right-start": popover_default.modifiers.rightTop,
    "right-end": popover_default.modifiers.rightBottom
  };
  const hasCustomMinWidth = minWidth !== c_popover_MinWidth_default.value;
  const hasCustomMaxWidth = maxWidth !== c_popover_MaxWidth_default.value;
  const onDocumentKeyDown = (event) => {
    if (event.key === KeyTypes.Escape && visible) {
      if (triggerManually) {
        shouldClose(event, hide2);
      } else {
        hide2(event);
      }
    }
  };
  const onDocumentClick = (event, triggerElement, popperElement) => {
    if (hideOnOutsideClick && visible) {
      const isFromChild = popperElement && popperElement.contains(event.target);
      const isFromTrigger = triggerElement && triggerElement.contains(event.target);
      if (isFromChild || isFromTrigger) {
        return;
      }
      if (triggerManually) {
        shouldClose(event, hide2);
      } else {
        hide2(event);
      }
    }
  };
  const onTriggerClick = (event) => {
    if (triggerManually) {
      if (visible) {
        shouldClose(event, hide2);
      } else {
        shouldOpen(event, show);
      }
    } else {
      if (visible) {
        hide2(event);
      } else {
        show(event, true);
      }
    }
  };
  const onContentMouseDown = () => {
    if (focusTrapActive) {
      setFocusTrapActive(false);
    }
  };
  const onMouseEnter = (event) => {
    if (triggerManually) {
      shouldOpen(event, show);
    } else {
      show(event, false);
    }
  };
  const onMouseLeave = (event) => {
    if (triggerManually) {
      shouldClose(event, hide2);
    } else {
      hide2(event);
    }
  };
  const onFocus = (event) => {
    if (triggerManually) {
      shouldOpen(event, show);
    } else {
      show(event, false);
    }
  };
  const onBlur = (event) => {
    if (triggerManually) {
      shouldClose(event, hide2);
    } else {
      hide2(event);
    }
  };
  const closePopover = (event) => {
    event.stopPropagation();
    if (triggerManually) {
      shouldClose(event, hide2);
    } else {
      hide2(event);
    }
  };
  const content = (0, import_jsx_runtime43.jsxs)(FocusTrap, Object.assign({ ref: popoverRef, active: focusTrapActive, focusTrapOptions: {
    returnFocusOnDeactivate: propWithFocusTrap !== false,
    clickOutsideDeactivates: true,
    // FocusTrap's initialFocus can accept false as a value to prevent initial focus.
    // We want to prevent this in case false is ever passed in.
    initialFocus: elementToFocus || void 0,
    checkCanFocusTrap: (containers) => new Promise((resolve) => {
      const interval = setInterval(() => {
        if (containers.every((container) => getComputedStyle(container).visibility !== "hidden")) {
          clearInterval(interval);
          resolve();
        }
      }, 10);
      const timeout = setTimeout(() => {
        clearInterval(interval);
        resolve();
      }, 5e3);
      resolve._cleanup = () => {
        clearInterval(interval);
        clearTimeout(timeout);
      };
    }),
    tabbableOptions: { displayCheck: "none" },
    fallbackFocus: () => {
      let node = null;
      if (document && document.activeElement) {
        node = document.activeElement;
      }
      return node;
    }
  }, preventScrollOnDeactivate: true, className: css(popover_default.popover, alertSeverityVariant && alertStyle[alertSeverityVariant], hasNoPadding && popover_default.modifiers.noPadding, hasAutoWidth && popover_default.modifiers.widthAuto, className), role: "dialog", "aria-modal": "true", "aria-label": headerContent ? void 0 : ariaLabel, "aria-labelledby": headerContent ? `popover-${uniqueId}-header` : void 0, "aria-describedby": `popover-${uniqueId}-body`, onMouseDown: onContentMouseDown, style: {
    minWidth: hasCustomMinWidth ? minWidth : null,
    maxWidth: hasCustomMaxWidth ? maxWidth : null
  } }, rest, { children: [(0, import_jsx_runtime43.jsx)(PopoverArrow, {}), (0, import_jsx_runtime43.jsxs)(PopoverContent, { children: [showClose && triggerAction === "click" && (0, import_jsx_runtime43.jsx)(PopoverCloseButton, { onClose: closePopover, "aria-label": closeBtnAriaLabel }), headerContent && (0, import_jsx_runtime43.jsx)(PopoverHeader, { id: `popover-${uniqueId}-header`, icon: headerIcon, alertSeverityVariant, alertSeverityScreenReaderText: alertSeverityScreenReaderText || `${alertSeverityVariant} alert:`, titleHeadingLevel: headerComponent, children: typeof headerContent === "function" ? headerContent(hide2) : headerContent }), (0, import_jsx_runtime43.jsx)(PopoverBody, { id: `popover-${uniqueId}-body`, children: typeof bodyContent === "function" ? bodyContent(hide2) : bodyContent }), footerContent && (0, import_jsx_runtime43.jsx)(PopoverFooter, { id: `popover-${uniqueId}-footer`, children: typeof footerContent === "function" ? footerContent(hide2) : footerContent })] })] }));
  return (0, import_jsx_runtime43.jsx)(PopoverContext.Provider, { value: { headerComponent }, children: (0, import_jsx_runtime43.jsx)(Popper, { trigger: children, triggerRef, popper: content, popperRef: popoverRef, minWidth, appendTo, isVisible: visible, onMouseEnter: triggerAction === "hover" && onMouseEnter, onMouseLeave: triggerAction === "hover" && onMouseLeave, onPopperMouseEnter: triggerAction === "hover" && onMouseEnter, onPopperMouseLeave: triggerAction === "hover" && onMouseLeave, onFocus: triggerAction === "hover" && onFocus, onBlur: triggerAction === "hover" && onBlur, positionModifiers, distance, placement: position, onTriggerClick: triggerAction === "click" && onTriggerClick, onDocumentClick, onDocumentKeyDown, enableFlip, zIndex, flipBehavior, animationDuration, onHidden, onShown, onHide: () => setFocusTrapActive(false) }) });
};
Popover.displayName = "Popover";

// node_modules/@patternfly/react-core/dist/esm/components/Divider/Divider.js
var import_jsx_runtime44 = __toESM(require_jsx_runtime());

// node_modules/@patternfly/react-styles/css/components/Divider/divider.mjs
import "/Users/pamparan/Desktop/Edge - AI Design support  /amplify-edge/frontend/node_modules/@patternfly/react-styles/css/components/Divider/divider.css";
var divider_default = {
  "divider": "pf-v6-c-divider",
  "modifiers": {
    "hidden": "pf-m-hidden",
    "hiddenOnSm": "pf-m-hidden-on-sm",
    "visibleOnSm": "pf-m-visible-on-sm",
    "hiddenOnMd": "pf-m-hidden-on-md",
    "visibleOnMd": "pf-m-visible-on-md",
    "hiddenOnLg": "pf-m-hidden-on-lg",
    "visibleOnLg": "pf-m-visible-on-lg",
    "hiddenOnXl": "pf-m-hidden-on-xl",
    "visibleOnXl": "pf-m-visible-on-xl",
    "hiddenOn_2xl": "pf-m-hidden-on-2xl",
    "visibleOn_2xl": "pf-m-visible-on-2xl",
    "horizontal": "pf-m-horizontal",
    "vertical": "pf-m-vertical",
    "insetNone": "pf-m-inset-none",
    "insetXs": "pf-m-inset-xs",
    "insetSm": "pf-m-inset-sm",
    "insetMd": "pf-m-inset-md",
    "insetLg": "pf-m-inset-lg",
    "insetXl": "pf-m-inset-xl",
    "inset_2xl": "pf-m-inset-2xl",
    "inset_3xl": "pf-m-inset-3xl",
    "horizontalOnSm": "pf-m-horizontal-on-sm",
    "verticalOnSm": "pf-m-vertical-on-sm",
    "insetNoneOnSm": "pf-m-inset-none-on-sm",
    "insetXsOnSm": "pf-m-inset-xs-on-sm",
    "insetSmOnSm": "pf-m-inset-sm-on-sm",
    "insetMdOnSm": "pf-m-inset-md-on-sm",
    "insetLgOnSm": "pf-m-inset-lg-on-sm",
    "insetXlOnSm": "pf-m-inset-xl-on-sm",
    "inset_2xlOnSm": "pf-m-inset-2xl-on-sm",
    "inset_3xlOnSm": "pf-m-inset-3xl-on-sm",
    "horizontalOnMd": "pf-m-horizontal-on-md",
    "verticalOnMd": "pf-m-vertical-on-md",
    "insetNoneOnMd": "pf-m-inset-none-on-md",
    "insetXsOnMd": "pf-m-inset-xs-on-md",
    "insetSmOnMd": "pf-m-inset-sm-on-md",
    "insetMdOnMd": "pf-m-inset-md-on-md",
    "insetLgOnMd": "pf-m-inset-lg-on-md",
    "insetXlOnMd": "pf-m-inset-xl-on-md",
    "inset_2xlOnMd": "pf-m-inset-2xl-on-md",
    "inset_3xlOnMd": "pf-m-inset-3xl-on-md",
    "horizontalOnLg": "pf-m-horizontal-on-lg",
    "verticalOnLg": "pf-m-vertical-on-lg",
    "insetNoneOnLg": "pf-m-inset-none-on-lg",
    "insetXsOnLg": "pf-m-inset-xs-on-lg",
    "insetSmOnLg": "pf-m-inset-sm-on-lg",
    "insetMdOnLg": "pf-m-inset-md-on-lg",
    "insetLgOnLg": "pf-m-inset-lg-on-lg",
    "insetXlOnLg": "pf-m-inset-xl-on-lg",
    "inset_2xlOnLg": "pf-m-inset-2xl-on-lg",
    "inset_3xlOnLg": "pf-m-inset-3xl-on-lg",
    "horizontalOnXl": "pf-m-horizontal-on-xl",
    "verticalOnXl": "pf-m-vertical-on-xl",
    "insetNoneOnXl": "pf-m-inset-none-on-xl",
    "insetXsOnXl": "pf-m-inset-xs-on-xl",
    "insetSmOnXl": "pf-m-inset-sm-on-xl",
    "insetMdOnXl": "pf-m-inset-md-on-xl",
    "insetLgOnXl": "pf-m-inset-lg-on-xl",
    "insetXlOnXl": "pf-m-inset-xl-on-xl",
    "inset_2xlOnXl": "pf-m-inset-2xl-on-xl",
    "inset_3xlOnXl": "pf-m-inset-3xl-on-xl",
    "horizontalOn_2xl": "pf-m-horizontal-on-2xl",
    "verticalOn_2xl": "pf-m-vertical-on-2xl",
    "insetNoneOn_2xl": "pf-m-inset-none-on-2xl",
    "insetXsOn_2xl": "pf-m-inset-xs-on-2xl",
    "insetSmOn_2xl": "pf-m-inset-sm-on-2xl",
    "insetMdOn_2xl": "pf-m-inset-md-on-2xl",
    "insetLgOn_2xl": "pf-m-inset-lg-on-2xl",
    "insetXlOn_2xl": "pf-m-inset-xl-on-2xl",
    "inset_2xlOn_2xl": "pf-m-inset-2xl-on-2xl",
    "inset_3xlOn_2xl": "pf-m-inset-3xl-on-2xl"
  }
};

// node_modules/@patternfly/react-core/dist/esm/components/Divider/Divider.js
var DividerVariant;
(function(DividerVariant2) {
  DividerVariant2["hr"] = "hr";
  DividerVariant2["li"] = "li";
  DividerVariant2["div"] = "div";
})(DividerVariant || (DividerVariant = {}));
var Divider = (_a) => {
  var { className, component = DividerVariant.hr, inset, orientation, role = "separator" } = _a, props = __rest(_a, ["className", "component", "inset", "orientation", "role"]);
  const Component9 = component;
  return (0, import_jsx_runtime44.jsx)(Component9, Object.assign({ className: css(divider_default.divider, formatBreakpointMods(inset, divider_default), formatBreakpointMods(orientation, divider_default), className) }, component !== "hr" && { role }, props));
};
Divider.displayName = "Divider";

// node_modules/@patternfly/react-core/dist/esm/components/Dropdown/Dropdown.js
var import_jsx_runtime45 = __toESM(require_jsx_runtime());
var import_react32 = __toESM(require_react());
var DropdownBase = (_a) => {
  var { children, className, onSelect, isOpen, toggle, shouldFocusToggleOnSelect = false, onOpenChange, onToggleKeydown, isPlain, isScrollable, innerRef, ouiaId, ouiaSafe = true, zIndex = 9999, popperProps, onOpenChangeKeys = ["Escape", "Tab"], menuHeight, maxMenuHeight, shouldFocusFirstItemOnOpen = false, shouldPreventScrollOnItemFocus = true, focusTimeoutDelay = 0 } = _a, props = __rest(_a, ["children", "className", "onSelect", "isOpen", "toggle", "shouldFocusToggleOnSelect", "onOpenChange", "onToggleKeydown", "isPlain", "isScrollable", "innerRef", "ouiaId", "ouiaSafe", "zIndex", "popperProps", "onOpenChangeKeys", "menuHeight", "maxMenuHeight", "shouldFocusFirstItemOnOpen", "shouldPreventScrollOnItemFocus", "focusTimeoutDelay"]);
  const localMenuRef = (0, import_react32.useRef)(void 0);
  const localToggleRef = (0, import_react32.useRef)(void 0);
  const ouiaProps = useOUIAProps(Dropdown.displayName, ouiaId, ouiaSafe);
  const menuRef = innerRef || localMenuRef;
  const toggleRef = typeof toggle === "function" || typeof toggle !== "function" && !toggle.toggleRef ? localToggleRef : toggle === null || toggle === void 0 ? void 0 : toggle.toggleRef;
  const prevIsOpen = (0, import_react32.useRef)(isOpen);
  (0, import_react32.useEffect)(() => {
    if (prevIsOpen.current === false && isOpen === true && shouldFocusFirstItemOnOpen) {
      setTimeout(() => {
        var _a2;
        const firstElement = (_a2 = menuRef === null || menuRef === void 0 ? void 0 : menuRef.current) === null || _a2 === void 0 ? void 0 : _a2.querySelector('li button:not(:disabled),li input:not(:disabled),li a:not([aria-disabled="true"])');
        firstElement && firstElement.focus({ preventScroll: shouldPreventScrollOnItemFocus });
      }, focusTimeoutDelay);
    }
    prevIsOpen.current = isOpen;
  }, [isOpen]);
  (0, import_react32.useEffect)(() => {
    const handleMenuKeys = (event) => {
      var _a2, _b, _c, _d;
      if (isOpen && onOpenChange && (((_a2 = menuRef.current) === null || _a2 === void 0 ? void 0 : _a2.contains(event.target)) || ((_b = toggleRef.current) === null || _b === void 0 ? void 0 : _b.contains(event.target)))) {
        if (onOpenChangeKeys.includes(event.key)) {
          onOpenChange(false);
          (_c = toggleRef.current) === null || _c === void 0 ? void 0 : _c.focus();
        }
      }
      if ((_d = toggleRef.current) === null || _d === void 0 ? void 0 : _d.contains(event.target)) {
        if (onToggleKeydown) {
          onToggleKeydown(event);
        } else if (isOpen) {
          onToggleArrowKeydownDefault(event, menuRef);
        }
      }
    };
    const handleClick = (event) => {
      var _a2, _b;
      if (isOpen && onOpenChange && !((_a2 = toggleRef === null || toggleRef === void 0 ? void 0 : toggleRef.current) === null || _a2 === void 0 ? void 0 : _a2.contains(event.target))) {
        if (isOpen && !((_b = menuRef.current) === null || _b === void 0 ? void 0 : _b.contains(event.target))) {
          onOpenChange(false);
        }
      }
    };
    window.addEventListener("keydown", handleMenuKeys);
    window.addEventListener("click", handleClick);
    return () => {
      window.removeEventListener("keydown", handleMenuKeys);
      window.removeEventListener("click", handleClick);
    };
  }, [
    isOpen,
    menuRef,
    toggleRef,
    onOpenChange,
    onOpenChangeKeys,
    onToggleKeydown,
    shouldPreventScrollOnItemFocus,
    shouldFocusFirstItemOnOpen,
    focusTimeoutDelay
  ]);
  const scrollable = maxMenuHeight !== void 0 || menuHeight !== void 0 || isScrollable;
  const menu = (0, import_jsx_runtime45.jsx)(Menu, Object.assign({ className: css(className), ref: menuRef, onSelect: (event, value) => {
    var _a2;
    onSelect && onSelect(event, value);
    shouldFocusToggleOnSelect && ((_a2 = toggleRef.current) === null || _a2 === void 0 ? void 0 : _a2.focus());
  }, isPlain, isScrollable: scrollable }, props, ouiaProps, { children: (0, import_jsx_runtime45.jsx)(MenuContent, { menuHeight, maxMenuHeight, children }) }));
  return (0, import_jsx_runtime45.jsx)(Popper, Object.assign({ trigger: typeof toggle === "function" ? toggle(toggleRef) : toggle.toggleNode, triggerRef: toggleRef, popper: menu, popperRef: menuRef, isVisible: isOpen, zIndex }, popperProps));
};
var Dropdown = (0, import_react32.forwardRef)((props, ref) => (0, import_jsx_runtime45.jsx)(DropdownBase, Object.assign({ innerRef: ref }, props)));
Dropdown.displayName = "Dropdown";

// node_modules/@patternfly/react-core/dist/esm/components/Dropdown/DropdownGroup.js
var import_jsx_runtime46 = __toESM(require_jsx_runtime());
var DropdownGroup = (_a) => {
  var { children, className, label, labelHeadingLevel = "h1" } = _a, props = __rest(_a, ["children", "className", "label", "labelHeadingLevel"]);
  return (0, import_jsx_runtime46.jsx)(MenuGroup, Object.assign({ className: css(className), label, labelHeadingLevel }, props, { children }));
};
DropdownGroup.displayName = "DropdownGroup";

// node_modules/@patternfly/react-core/dist/esm/components/Dropdown/DropdownItem.js
var import_jsx_runtime47 = __toESM(require_jsx_runtime());
var import_react33 = __toESM(require_react());
var DropdownItemBase = (_a) => {
  var { children, className, description, isDisabled, isAriaDisabled, value, onClick, ouiaId, ouiaSafe, innerRef, tooltipProps } = _a, props = __rest(_a, ["children", "className", "description", "isDisabled", "isAriaDisabled", "value", "onClick", "ouiaId", "ouiaSafe", "innerRef", "tooltipProps"]);
  const ouiaProps = useOUIAProps(DropdownItem.displayName, ouiaId, ouiaSafe);
  return (0, import_jsx_runtime47.jsx)(MenuItem, Object.assign({ className: css(className), description, isDisabled, isAriaDisabled, itemId: value, onClick, tooltipProps, ref: innerRef }, ouiaProps, props, { children }));
};
var DropdownItem = (0, import_react33.forwardRef)((props, ref) => (0, import_jsx_runtime47.jsx)(DropdownItemBase, Object.assign({}, props, { innerRef: ref })));
DropdownItem.displayName = "DropdownItem";

// node_modules/@patternfly/react-core/dist/esm/components/Dropdown/DropdownList.js
var import_jsx_runtime48 = __toESM(require_jsx_runtime());
var DropdownList = (_a) => {
  var { children, className } = _a, props = __rest(_a, ["children", "className"]);
  return (0, import_jsx_runtime48.jsx)(MenuList, Object.assign({ className: css(className) }, props, { children }));
};
DropdownList.displayName = "DropdownList";

// node_modules/@patternfly/react-styles/css/components/Form/form.mjs
import "/Users/pamparan/Desktop/Edge - AI Design support  /amplify-edge/frontend/node_modules/@patternfly/react-styles/css/components/Form/form.css";
var form_default = {
  "button": "pf-v6-c-button",
  "dirRtl": "pf-v6-m-dir-rtl",
  "form": "pf-v6-c-form",
  "formActions": "pf-v6-c-form__actions",
  "formFieldGroup": "pf-v6-c-form__field-group",
  "formFieldGroupBody": "pf-v6-c-form__field-group-body",
  "formFieldGroupHeader": "pf-v6-c-form__field-group-header",
  "formFieldGroupHeaderActions": "pf-v6-c-form__field-group-header-actions",
  "formFieldGroupHeaderDescription": "pf-v6-c-form__field-group-header-description",
  "formFieldGroupHeaderMain": "pf-v6-c-form__field-group-header-main",
  "formFieldGroupHeaderTitle": "pf-v6-c-form__field-group-header-title",
  "formFieldGroupHeaderTitleText": "pf-v6-c-form__field-group-header-title-text",
  "formFieldGroupToggle": "pf-v6-c-form__field-group-toggle",
  "formFieldGroupToggleButton": "pf-v6-c-form__field-group-toggle-button",
  "formFieldGroupToggleIcon": "pf-v6-c-form__field-group-toggle-icon",
  "formFieldset": "pf-v6-c-form__fieldset",
  "formGroup": "pf-v6-c-form__group",
  "formGroupControl": "pf-v6-c-form__group-control",
  "formGroupLabel": "pf-v6-c-form__group-label",
  "formGroupLabelHelp": "pf-v6-c-form__group-label-help",
  "formGroupLabelInfo": "pf-v6-c-form__group-label-info",
  "formGroupLabelMain": "pf-v6-c-form__group-label-main",
  "formHelperText": "pf-v6-c-form__helper-text",
  "formLabel": "pf-v6-c-form__label",
  "formLabelRequired": "pf-v6-c-form__label-required",
  "formLabelText": "pf-v6-c-form__label-text",
  "formSection": "pf-v6-c-form__section",
  "formSectionTitle": "pf-v6-c-form__section-title",
  "modifiers": {
    "horizontal": "pf-m-horizontal",
    "alignRight": "pf-m-align-right",
    "noPaddingTop": "pf-m-no-padding-top",
    "info": "pf-m-info",
    "horizontalOnXs": "pf-m-horizontal-on-xs",
    "horizontalOnSm": "pf-m-horizontal-on-sm",
    "horizontalOnMd": "pf-m-horizontal-on-md",
    "horizontalOnLg": "pf-m-horizontal-on-lg",
    "horizontalOnXl": "pf-m-horizontal-on-xl",
    "horizontalOn_2xl": "pf-m-horizontal-on-2xl",
    "limitWidth": "pf-m-limit-width",
    "action": "pf-m-action",
    "disabled": "pf-m-disabled",
    "inline": "pf-m-inline",
    "stack": "pf-m-stack",
    "inactive": "pf-m-inactive",
    "hidden": "pf-m-hidden",
    "expanded": "pf-m-expanded",
    "expandable": "pf-m-expandable"
  }
};

export {
  css,
  t_global_breakpoint_md_default,
  t_global_breakpoint_lg_default,
  t_global_breakpoint_xl_default,
  t_global_breakpoint_2xl_default,
  SIDE,
  KEYHANDLER_DIRECTION,
  ValidatedOptions,
  KeyTypes,
  globalWidthBreakpoints,
  globalHeightBreakpoints,
  statusIcons,
  FocusTrap,
  capitalize,
  getUniqueId,
  debounce,
  isElementInView,
  sideElementIsOutOfView,
  fillTemplate,
  keyHandler,
  findTabbableElements,
  getNextIndex,
  pluralize,
  setBreakpointCssVars,
  formatBreakpointMods,
  getVerticalBreakpoint,
  getBreakpoint,
  toCamel,
  canUseDOM,
  getTextWidth,
  innerDimensions,
  trimLeft,
  preventedEvents,
  clearTimeouts,
  getLanguageDirection,
  getReferenceElement,
  getInlineStartProperty,
  GenerateId,
  ASTERISK,
  getOUIAProps,
  useOUIAProps,
  useOUIAId,
  getDefaultOUIAId,
  useIsomorphicLayoutEffect,
  getOpacityTransition,
  Popper,
  handleArrows,
  setTabIndex,
  onToggleArrowKeydownDefault,
  KeyboardHandler,
  getResizeObserver,
  useInterval,
  isValidDate,
  button_default,
  spinnerSize,
  Spinner,
  Badge,
  ButtonVariant,
  ButtonType,
  ButtonSize,
  ButtonState,
  Button,
  TooltipPosition,
  Tooltip,
  ActionList,
  ActionListGroup,
  ActionListItem,
  breadcrumb_default,
  form_control_default,
  FormControlIcon,
  TextInputTypes,
  TextInputReadOnlyVariant,
  TextInputBase,
  TextInput,
  menu_default,
  Menu,
  MenuContent,
  MenuFooter,
  MenuSearch,
  MenuSearchInput,
  MenuGroup,
  check_default,
  Checkbox,
  MenuItemAction,
  MenuItem,
  MenuList,
  DrilldownMenu,
  MenuBreadcrumb,
  MenuContainer,
  Select,
  SelectGroup,
  SelectList,
  SelectOption,
  MenuToggleStatus,
  MenuToggleSize,
  MenuToggle,
  MenuToggleAction,
  MenuToggleCheckbox,
  PopoverPosition,
  Popover,
  divider_default,
  DividerVariant,
  Divider,
  Dropdown,
  DropdownGroup,
  DropdownItem,
  DropdownList,
  form_default
};
/*! Bundled license information:

tabbable/dist/index.esm.js:
  (*!
  * tabbable 6.2.0
  * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
  *)

focus-trap/dist/focus-trap.esm.js:
  (*!
  * focus-trap 7.6.4
  * @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE
  *)
*/
//# sourceMappingURL=chunk-5CKKRT4D.js.map
